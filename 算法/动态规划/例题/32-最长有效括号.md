方法 2：动态规划

算法

这个问题可以通过动态规划解决。我们定义一个dp数组，其中第 

i个元素表示以下标为i的字符结尾的最长有效子字符串的长度。我们将 

dp数组全部初始化为 0 。现在，很明显有效的子字符串一定以 

‘)’结尾。这进一步可以得出结论：以 ‘(’结尾的子字符串对应的 

dp数组位置上的值必定为 0 。所以说我们只需要更新 

‘)’在 dp数组中对应位置的值。



为了求出dp数组，我们每两个字符检查一次，如果满足如下条件

1. s[i] = ')' 且 s[i-1] = '(',也就是字符串形如".....()", 我们可以推出：

dp[i] = dp[i-2] + 2

我们可以进行这样的转移，是因为结束部分的"()"是一个有效子字符串，

并且将之前有效子字符串的长度增加了 2 。

2. s[i] = ')' 且 s[i-1] = ')',也就是字符串形如".....))", 我们可以推出：

如果s[i - dp[i-1] - 1] = '(', 那么

dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]

这背后的原因是如果倒数第二个'('是一个有效子字符串的一部分（记为sub),

对于最后一个 ‘)’，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 ‘(’，

它的位置在倒数第二个 ‘)’所在的有效子字符串的前面（也就是sub的前面）。

因此，如果子字符串sub 的前面恰好是'(',，那么我们就用 2加上sub的长度

(dp[i-1]) 去更新dp[i]。除此以外，我们也会把有效子字符串"(,sub,)"

之前的有效子字符串的长度也加上，也就是加上dp[i-dp[i-1]-2]

复杂度分析

时间复杂度：O(n)。遍历整个字符串一次，就可以将 dp 数组求出来。

空间复杂度：O(n) 。需要一个大小为 n 的 dp 数组



class Solution:

    def longestValidParentheses(self, s: str) -> int:

        n = len(s)

        if n == 0: return 0

        dp = [0] * n

        res = 0

        for i in range(n):

            if i>0 and s[i] == ")":

                if  s[i - 1] == "(":

                    dp[i] = dp[i - 2] + 2

                elif s[i - 1] == ")" and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == "(":

                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]

                if dp[i] > res:

                    res = dp[i]

        return res












'''

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"

输出: 2

解释: 最长有效括号子串为 "()"

示例 2:

输入: ")()())"

输出: 4

解释: 最长有效括号子串为 "()()"

'''


