[743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´](https://leetcode-cn.com/problems/network-delay-time/)

[å››ç§å¸¸ç”¨çš„æœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œå¯ä»¥çœ‹ä¸‹è¿™é‡Œ](https://github.com/DoWalle/algorithm/blob/main/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md)

## æ–¹æ³•ä¸€ï¼šdijkstra

æ—¶é—´å¤æ‚åº¦ï¼š`O(n*logn)`

ç©ºé—´å¤æ‚åº¦ï¼š`O(n^2)`

æ‰§è¡Œç”¨æ—¶ï¼š64 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†88.37%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š16.2 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†65.71%çš„ç”¨æˆ·

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # å¤„ç†ä¸‹èŠ‚ç‚¹æ˜¯ä» 1åˆ°n æ ‡è®°çš„
        adj = collections.defaultdict(list)
        for s, e, cost in times:
            adj[s-1].append((e-1, cost))
        start = k - 1
        node_sz = n 
        visited = [False for _ in range(node_sz)] # è®°å½•å·²ç»ç¡®å®šæœ€çŸ­è·¯å¾„çš„ç‚¹
        dis = [float("inf") for _ in range(node_sz)] # è®°å½•ä»æºç‚¹åˆ°ç›®æ ‡ç‚¹çš„ã€Œé¢„ä¼°æœ€çŸ­è·ç¦»ã€

        dis[start] = 0
        queue = []
        heapq.heappush(queue, (dis[start], start))

        while queue:
            _, cur = heapq.heappop(queue)
            if visited[cur]:
                continue
            
            visited[cur] = True

            for n_idx, val in adj[cur]:
                if dis[cur] + val < dis[n_idx]:
                    dis[n_idx] = dis[cur] + val
                    heapq.heappush(queue, (dis[n_idx], n_idx))
        # print(dis)

        ans = 0
        for d in dis:
            if d == float("inf"):
                return -1
            ans = max(ans, d)
        return ans
```



## æ–¹æ³•äºŒï¼šFloyd

æ—¶é—´å¤æ‚åº¦ï¼š`O(n^3)`

ç©ºé—´å¤æ‚åº¦ï¼š`O(n^2)`

æ‰§è¡Œç”¨æ—¶ï¼š1000 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†6.91%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š16.3 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†38.50%çš„ç”¨æˆ·

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # å¤„ç†ä¸‹èŠ‚ç‚¹æ˜¯ä» 1åˆ°n æ ‡è®°çš„
        start = k - 1
        node_sz = n 
        adj = [[float("inf") for _ in range(node_sz)] for _ in range(node_sz)]
        for n in range(node_sz):
            adj[n][n] = 0
        for s, e, v in times:
            adj[s-1][e-1] = v

        for mid in range(0, node_sz):
            for s in range(0, node_sz):
                for e in range(0, node_sz):
                    adj[s][e] = min(adj[s][e], adj[s][mid]+adj[mid][e])
        # print(adj)

        ans = 0
        for d in adj[start]:
            if d == float("inf"):
                return -1
            ans = max(ans, d)
        return ans
```





## æ–¹æ³•äºŒï¼šbfs

æ—¶é—´å¤æ‚åº¦ï¼š`O(n^2)`ï¼Œå‡è®¾æ¯ä¸ªç‚¹éƒ½ä¸å…¶ä½™çš„ç‚¹ç›¸è¿

ç©ºé—´å¤æ‚åº¦ï¼š`O(n^2)`

æ‰§è¡Œç”¨æ—¶ï¼š92 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†34.12%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š16.3 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†25.25%çš„ç”¨æˆ·

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # é‚»æ¥è¡¨ u -> v w
        adj = collections.defaultdict(list)
        for u, v, w in times:
            adj[u].append((v, w))
        
        queue = [(k, 0)]
        dis = [-1 for _ in range(n+1)] # è®°å½•ç»“ç‚¹æœ€æ—©æ”¶åˆ°ä¿¡å·çš„æ—¶é—´
        dis[k] = 0
        while queue:
            cur, path = queue.pop(0)
            for n_node, cost in adj[cur]:
                if dis[n_node] == -1 or path + cost < dis[n_node]:
                    # ä»…å½“ç»“ç‚¹æœªæ”¶åˆ°æˆ–æ”¶åˆ°æ—¶é—´æ¯”è®°å½•æ—¶é—´æ›´æ—©æ‰æ›´æ–°å¹¶å…¥é˜Ÿ
                    dis[n_node] = path + cost
                    queue.append((n_node, path + cost))
        ans = 0
        for t in dis[1:]:
            if t == -1:
                return -1
            ans = max(ans, t)
        return ans
```



## æ–¹æ³•ä¸‰ï¼šdfs + å‰ªæ

æ—¶é—´å¤æ‚åº¦ï¼š`O(n^n)`ï¼Œå‡è®¾æ¯ä¸ªç‚¹éƒ½ä¸å…¶ä½™çš„ç‚¹ç›¸è¿

ç©ºé—´å¤æ‚åº¦ï¼š`O(n)`ï¼Œé‚»æ¥è¡¨ `O(n)`ï¼Œé€’å½’æ ˆ`O(n)`

æ‰§è¡Œç”¨æ—¶ï¼š3484 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†5.07%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š17.4 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†5.32%çš„ç”¨æˆ·

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # é‚»æ¥è¡¨ u -> v w
        adj = collections.defaultdict(list)
        for u, v, w in times:
            adj[u].append((v, w))
        dis = [-1 for _ in range(n+1)]
        dis[k] = 0
        
        def dfs(node, path):
            for n_node, cost in adj[node]:
                if dis[n_node] == -1 or path + cost < dis[n_node]:
                    # å¦‚æœæ²¡æœ‰åˆ°è¾¾ï¼Œä¸”è·¯å¾„æ¯”ä»¥å‰çŸ­ï¼Œæ‰èƒ½è¿›å…¥é€’å½’
                    dis[n_node] = path + cost
                    dfs(n_node, path + cost)
        
        dfs(k, 0)
        ans = 0
        for t in dis[1:]:
            if t == -1:
                return -1
            ans = max(ans, t)
        return ans
```



`æ„Ÿè°¢`  å¤§å®¶ç‚¹èµ StarğŸŒŸ [https://github.com/DoWalle/algorithm](https://github.com/DoWalle/algorithm) ç¬”èŠ¯ğŸ¤

`å‘å¸ƒ`  äº Gitbook [https://dowalle.gitbook.io/algo/](https://dowalle.gitbook.io/algo/)https://dowalle.gitbook.io/algo/)

