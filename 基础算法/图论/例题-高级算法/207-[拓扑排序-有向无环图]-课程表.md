[207. è¯¾ç¨‹è¡¨](https://leetcode-cn.com/problems/course-schedule/)

## æ–¹æ³•ä¸€ï¼škahn ç®—æ³•

æ—¶é—´å¤æ‚åº¦ï¼š`O(n+m)`ï¼Œå…¶ä¸­ n ä¸ºè¯¾ç¨‹æ•°ï¼Œm ä¸ºå…ˆä¿®è¯¾ç¨‹çš„è¦æ±‚æ•°

ç©ºé—´å¤æ‚åº¦ï¼š`O(n+m)`ï¼Œé‚»æ¥è¡¨æ‰€éœ€çš„ç©ºé—´ä¸º`O(n+m)`ï¼Œé˜Ÿåˆ—æ‰€éœ€çš„ç©ºé—´ä¸º`O(n)`

æ‰§è¡Œç”¨æ—¶ï¼š36 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†84.58%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š15.7 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†64.10%çš„ç”¨æˆ·

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        adj = collections.defaultdict(list)
        indegree = collections.defaultdict(int)
        topo = []

        # 1ã€åˆ›å»ºé‚»æ¥è¡¨å’Œå…¥åº¦è¡¨
        for a, b in prerequisites:
            adj[b].append(a)
            indegree[a] += 1

        # 2ã€å…¥åº¦ä¸º 0 çš„ç‚¹è¿›å…¥é˜Ÿåˆ—
        queue = collections.deque([k for k in range(numCourses) if indegree[k] == 0])
        while queue:
            node = queue.popleft()
            topo.append(node)               # 3ã€topoä¸­è®°å½•å…¥åº¦ä¸º0çš„ç‚¹
            for n_node in adj[node]:
                indegree[n_node] -= 1       # 4ã€èµ°åˆ°ä¸€ä¸ªç‚¹æ—¶å…¥åº¦å‡ä¸€
                if indegree[n_node] == 0:
                    queue.append(n_node)    # 5ã€ä¸‹ä¸€ä¸ªç‚¹å…¥åº¦ä¸º0ï¼Œå¯è¿›å…¥é˜Ÿåˆ—
        
        # print(topo)
        return len(topo) == numCourses
```

æ‰§è¡Œç”¨æ—¶ï¼š8 ms, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†94.81%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6.2 MB, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†51.58%çš„ç”¨æˆ·

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
	adj := map[int][]int{}
	indegree := map[int]int{}
	topo := []int{}

	// 1ã€åˆ›å»ºé‚»æ¥è¡¨å’Œå…¥åº¦è¡¨
	for _, pre := range prerequisites {
		adj[pre[1]] = append(adj[pre[1]], pre[0])
		indegree[pre[0]]++
	}
	// fmt.Println(adj)
	// fmt.Println(indegree)

	// 2ã€å…¥åº¦ä¸º 0 çš„ç‚¹è¿›å…¥é˜Ÿåˆ—
	queue := []int{}
	for k := 0; k < numCourses; k++ {
		if indegree[k] == 0 {
			queue = append(queue, k)
		}
	}
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		topo = append(topo, node) // 3ã€topoä¸­è®°å½•å…¥åº¦ä¸º0çš„ç‚¹
		for _, n_node := range adj[node] {
			indegree[n_node]-- // 4ã€èµ°åˆ°ä¸€ä¸ªç‚¹æ—¶å…¥åº¦å‡ä¸€
			if indegree[n_node] == 0 {
				queue = append(queue, n_node) // 5ã€ä¸‹ä¸€ä¸ªç‚¹å…¥åº¦ä¸º0ï¼Œå¯è¿›å…¥é˜Ÿåˆ—
			}
		}
	}

	return len(topo) == numCourses
}
```



## æ–¹æ³•äºŒï¼šdfs

æ‰§è¡Œç”¨æ—¶ï¼š40 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†66.14%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š17.8 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†24.67%çš„ç”¨æˆ·

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        adj = collections.defaultdict(list)  # é‚»æ¥è¡¨
        flags = collections.defaultdict(int)  # æ ‡å¿—è¡¨ï¼Œ0æ²¡è®¿é—®è¿‡ï¼Œ-1å·²è®¿é—®è¿‡ï¼Œ1å½“å‰æ­£åœ¨è®¿é—®
        topo = []  # æ‹“æ‰‘æ’åºçš„é€†åº

        # åˆ›å»ºé‚»æ¥è¡¨
        for a, b in prerequisites:
            adj[b].append(a)

        def dfs(node):
            if flags[node] == -1:
                return True
            if flags[node] == 1:
                return False

            flags[node] = 1
            for n_node in adj[node]:
                if not dfs(n_node):
                    return False

            flags[node] = -1
            topo.append(node)
            return True

        # æ¯ä¸ªç‚¹è¿›è¡Œæ— ç¯åˆ¤æ–­
        for n in range(numCourses):
            if not dfs(n):
                return False

        # print(topo[::-1])
        return True
```

æ‰§è¡Œç”¨æ—¶ï¼š12 ms, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†70.61%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6.6 MB, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†17.14%çš„ç”¨æˆ·

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
	adj := map[int][]int{} // é‚»æ¥è¡¨
	flags := map[int]int{} // æ ‡å¿—è¡¨ï¼Œ0æ²¡è®¿é—®è¿‡ï¼Œ-1å·²è®¿é—®è¿‡ï¼Œ1å½“å‰æ­£åœ¨è®¿é—®
	var topo *[]int        // ä¿å­˜é€†åºçš„æ‹“æ‰‘æ’åºï¼Œå…¶å®ç”¨ä¸ªæ•°ç»„ä¹Ÿè¡Œï¼Œè¿™é‡Œæƒ³è¯•è¯•æ•°æ®æŒ‡é’ˆ
	topo = &[]int{}

	// åˆ›å»ºé‚»æ¥è¡¨
	for _, pre := range prerequisites {
		adj[pre[1]] = append(adj[pre[1]], pre[0])
	}

	var dfs func(int, *[]int) bool
	dfs = func(node int, topo *[]int) bool {
		if flags[node] == -1 {
			return true
		}
		if flags[node] == 1 {
			return false
		}

		flags[node] = 1
		for _, n_node := range adj[node] {
			if ok := dfs(n_node, topo); !ok {
				return false
			}
		}
		flags[node] = -1
		*topo = append(*topo, node)
		return true
	}
	
  // æ¯ä¸ªç‚¹è¿›è¡Œæ— ç¯åˆ¤æ–­
	for n := 0; n < numCourses; n++ {
		if ok := dfs(n, topo); !ok {
			return false
		}
	}
	fmt.Println(*topo) // golang ä¼¼ä¹æ²¡æœ‰é€†åºçš„å‡½æ•°
	return true
}
```

---

`æ„Ÿè°¢`  å¤§å®¶ç‚¹èµ StarğŸŒŸ [https://github.com/DoWalle/algorithm](https://github.com/DoWalle/algorithm) ç¬”èŠ¯ğŸ¤

`å‘å¸ƒ`  äº Gitbook [https://dowalle.gitbook.io/algo/](https://dowalle.gitbook.io/algo/)
