题目：[面试题 01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/)

字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。

```
示例1:

 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True

示例2:

 输入：s1 = "aa", s2 = "aba"
 输出：False
```

**提示：**

1. 字符串长度在[0, 100000]范围内。

**说明:**

1. 你能只调用一次检查子串的方法吗？

```c++
class Solution {
public:
    // KMP 算法
    // haystack: 原串(string)  needle: 匹配串(pattern)
    int strStr(string haystack, string needle) {

        if (needle.empty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = haystack.size(), m = needle.size();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        haystack = " " + haystack;
        needle = " " + needle;

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        vector<int> next(m+1, 0);

        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && needle[i] != needle[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (needle[i] == needle[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i <= n; i++) {
            // 匹配不成功 j = next(j)
            while (j > 0 && haystack[i] != needle[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (haystack[i] == needle[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }
        return -1;
    }

    bool isFlipedString(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        if (n1 == 0 && n2 == 0) return true;
        if (n1 != n2) return false;

        s2 = s2 + s2;
        int res = strStr(s2, s1);
        return res == -1 ? false : true;
    }
};
```

