[402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

## 方法：移除问题+单调栈

[题解来源](https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/)

```
给定一个以字符串表示的非负整数  num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

示例 1 :
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 :

输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是 0。
```

### 思路

这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。

一个思路是：

- 从左到右遍历
- 对于每一个遍历到的元素，我们决定是「丢弃」还是「保留」

问题的关键是：我们怎么知道，**一个元素是应该保留还是丢弃呢**？

### 前置知识

对于两个数 `1 2 3 a _ _ _` 和 `1 2 3 b _ _ _`

- 如果 a > b， 那么 `123a___` 大于 `123b___`
- 否则，那么 `123a___` 小于等于 `123b___`

**两个「相同位数」的数字大小关系取决于「第一个不同」的数的大小**

### 算法

- 从左到右遍历
- 对于遍历到的元素（从第二个元素开始），与前面的元素进行比较
- 如果比前一个元素小，就把前一个元素「替换」成当前小的元素
- 如果大于等于前一个元素，该元素直接「拼接」在后面

然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远不丢弃（另一方面可以用上面的算法找到一个单调递增数组）

题目中要求，要「丢弃」k 个，因此要增加个逻辑

- 每次「替换」一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历，并加上剩余的元素（后面的数字大小，不用关心）
- 如果遍历完成，k 仍然大于 0。假设还有 x 个需要丢弃，那么删除末尾 x 个元素

```
num = 1432219， k = 3
[1]
[1, 4]        4比1大，拼接
[1, 3]        3比4小，替换，k=2
[1, 2]        2比3小，替换，k=1
[1, 2, 2]     2等于2，拼接
[1, 2, 1]     1比2小，替换，k=0，结束
[1, 2, 1, 9]  提前结束需加上剩余的元素 9
```

注意：如果 k=4，在 `[1, 2, 1]` 这一步时，1 还需与前面的 2 比较，因为比 2 小，所以为 `[1, 1]`

### 实现算法

上面的算法实际上是与数组的一端进行比较，**数据结构采用「栈」**

不用担心 0 放在前面，因为把 002 有效为 2，**不会占用「移除次数」**

最后需要将数字有效化

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<int> stk;
        for (char c : num) {
            int digit = c - 48;
            while (k != 0 && !stk.empty() && digit < *stk.rbegin()) {
                stk.pop_back();
                k--;
            }
            // 此时k可能等于0，push_back会将剩余元素都添进去
            // k不等于0，但栈是空的，将下个元素无论大小都添进去
            // k不等于0，栈也不为空，但下个元素「大于等于」栈顶，将此元素添进去
            stk.push_back(digit);
        }
        // 遍历结束后，移除的次数可能不够 k 次，k 不等于 0
        // 因此移除后面多余的元素，移除剩下的 k 次
        while (k != 0) {
            stk.pop_back();
            k--;
        }
        // 返回答案前，把数字有效化（前面的 0 去掉）
        string ans;
        for (int digit : stk) {
            if (ans.size() == 0 && digit == 0) continue;
            ans += to_string(digit);
        }
        if (ans.size() == 0) ans = "0";
        return ans;
    }
};
```

