题目：[2537. 统计好子数组的数目](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回 `nums` 中 **好** 子数组的数目。

一个子数组 `arr` 如果有 **至少** `k` 对下标 `(i, j)` 满足 `i < j` 且 `arr[i] == arr[j]` ，那么称它是一个 **好** 子数组。

**子数组** 是原数组中一段连续 **非空** 的元素序列。

**示例 1：**

```
输入：nums = [1,1,1,1,1], k = 10
输出：1
解释：唯一的好子数组是这个数组本身。
```

**示例 2：**

```
输入：nums = [3,1,4,3,2,2,4], k = 2
输出：4
解释：总共有 4 个不同的好子数组：
- [3,1,4,3,2,2] 有 2 对。
- [3,1,4,3,2,2,4] 有 3 对。
- [1,4,3,2,2,4] 有 2 对。
- [4,3,2,2,4] 有 2 对。
```

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i], k <= 109`

---

本题的做法：

用一个哈希表 cnt 统计窗口内每个元素的出现次数。

枚举子数组右端点 right，那么答案增加了 cnt[nums[right]]；然后看左端点 left 最大可以是多少，如果去掉左端点，答案没有小于 k，就可以移动左端点。

由于左端点及其左边的都可以是好子数组的左端点，所以每个右端点对应的答案个数为 left+1。

```python
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        n = len(nums)
        l = 0
        r = 0
        windows = collections.defaultdict(int)
        pairs = 0
        ans = 0

        while r < n:
            pairs += windows[nums[r]]
            windows[nums[r]] += 1
            while pairs - windows[nums[l]] + 1 >= k:
                windows[nums[l]] -= 1
                pairs -= windows[nums[l]]
                l += 1
            if pairs >= k:
                ans += l + 1
            r += 1
        return ans
```

