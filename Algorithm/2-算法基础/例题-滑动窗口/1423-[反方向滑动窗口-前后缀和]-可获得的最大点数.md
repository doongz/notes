[1423. å¯è·å¾—çš„æœ€å¤§ç‚¹æ•°](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)

## æ–¹æ³•ä¸€ï¼šé€†å‘æ€ç»´çš„æ»‘åŠ¨çª—å£

- é¦–å’Œå°¾ä¸€å…±è¦é€‰ k ä¸ªå¡ç‰Œï¼Œæ„å‘³ç€ä¸­é—´ä¼šæœ‰ n-k ä¸ªè¿ç»­çš„å¡ç‰Œ
- cardPoints ä¸­çš„å€¼éƒ½æ˜¯æ­£æ•°ï¼Œå…·å¤‡å•è°ƒæ€§

ä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œçª—å£é•¿åº¦ä¸º len(cardPoints) - kï¼Œçª—å£å†…çš„å’Œæœ€å°ï¼Œæ„å‘³ç€çª—å£å¤–çš„ k ä¸ªå€¼çš„å’Œæœ€å¤§

æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`

ç©ºé—´å¤æ‚åº¦ï¼š`O(1)`

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int left = 0;
        int right = 0;
        int window_size = n - k;
        int window = 0;  // çª—å£å†…çš„å’Œ
        int min_window = INT_MAX;
        int all = 0;

        while (right < n) {
            all += cardPoints[right];
            window += cardPoints[right];
            // å·¦è¾¹ç•Œæ”¶ç¼©
            if (right - left + 1 > window_size) {
                window -= cardPoints[left];
                left++;
            }
            if (right - left + 1 == window_size) {
                min_window = min(min_window, window);
            }
            right++;
        }
        return all - min_window;
    }
};
```

## æ–¹æ³•äºŒï¼šå‰ç¼€å’Œ+åç¼€å’Œ

- é¦–æ‹¿ cnt å¼ ï¼Œ0<=cnt<=kï¼Œpre_sum ä¸­å¯¹åº”ä½ç½® pre_sum[cnt]
- å°¾æ‹¿ k-cnt å¼ ï¼Œsuf_sum ä¸­å¯¹åº”ä½ç½® suf_sum[sz-(k-cnt)]

æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`

ç©ºé—´å¤æ‚åº¦ï¼š`O(n)`

æ‰§è¡Œç”¨æ—¶ï¼š128 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†84.65%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š27.1 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†84.91%çš„ç”¨æˆ·

```python
class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        sz = len(cardPoints)
        pre_sum = [0 for _ in range(sz+1)]
        suf_sum = [0 for _ in range(sz+1)]
        for i in range(sz):
            pre_sum[i+1] = pre_sum[i] + cardPoints[i]
        for i in range(sz-1, -1, -1):
            suf_sum[i] = suf_sum[i+1] + cardPoints[i]

        # é¦–æ‹¿ cnt å¼ ï¼Œ0<=cnt<=kï¼Œpre_sum ä¸­å¯¹åº”ä½ç½® pre_sum[cnt]
        # å°¾æ‹¿ k-cnt å¼ ï¼Œsuf_sum ä¸­å¯¹åº”ä½ç½® suf_sum[sz-(k-cnt)]
        ans = 0
        for cnt in range(0, k+1):
            ans = max(ans, pre_sum[cnt] + suf_sum[sz-(k-cnt)])
        return ans
```

æ‰§è¡Œç”¨æ—¶ï¼š56 ms, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†45.45%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š8.9 MB, åœ¨æ‰€æœ‰ Go æäº¤ä¸­å‡»è´¥äº†6.82%çš„ç”¨æˆ·

```go
func maxScore(cardPoints []int, k int) int {
	sz := len(cardPoints)
	pre_sum := make([]int, sz+1)
	suf_sum := make([]int, sz+1)
	for i := 0; i < sz; i++ {
		pre_sum[i+1] = pre_sum[i] + cardPoints[i]
	}
	for i := sz - 1; i > -1; i-- {
		suf_sum[i] = suf_sum[i+1] + cardPoints[i]
	}

	var ans int = 0
	for cnt := 0; cnt < k+1; cnt++ {
		ans = max(ans, pre_sum[cnt]+suf_sum[sz-(k-cnt)])
	}
	return ans
}

func max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}
```

`æ„Ÿè°¢`  å¤§å®¶ç‚¹èµ StarğŸŒŸ [https://github.com/dowalle/algorithm](https://github.com/dowalle/algorithm) ç¬”èŠ¯ğŸ¤

