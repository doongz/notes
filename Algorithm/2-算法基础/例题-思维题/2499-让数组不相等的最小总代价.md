题目：[2499. 让数组不相等的最小总代价](https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/)

给你两个下标从 **0** 开始的整数数组 `nums1` 和 `nums2` ，两者长度都为 `n` 。

每次操作中，你可以选择交换 `nums1` 中任意两个下标处的值。操作的 **开销** 为两个下标的 **和** 。

你的目标是对于所有的 `0 <= i <= n - 1` ，都满足 `nums1[i] != nums2[i]` ，你可以进行 **任意次** 操作，请你返回达到这个目标的 **最小** 总代价。

请你返回让 `nums1` 和 `nums2` 满足上述条件的 **最小总代价** ，如果无法达成目标，返回 `-1` 。

**示例 1：**

```
输入：nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
输出：10
解释：
实现目标的其中一种方法为：
- 交换下标为 0 和 3 的两个值，代价为 0 + 3 = 3 。现在 nums1 = [4,2,3,1,5] 。
- 交换下标为 1 和 2 的两个值，代价为 1 + 2 = 3 。现在 nums1 = [4,3,2,1,5] 。
- 交换下标为 0 和 4 的两个值，代价为 0 + 4 = 4 。现在 nums1 = [5,3,2,1,4] 。
最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为 10 。
还有别的交换值的方法，但是无法得到代价和小于 10 的方案。
```

**示例 2：**

```
输入：nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
输出：10
解释：
实现目标的一种方法为：
- 交换下标为 2 和 3 的两个值，代价为 2 + 3 = 5 。现在 nums1 = [2,2,1,2,3] 。
- 交换下标为 1 和 4 的两个值，代价为 1 + 4 = 5 。现在 nums1 = [2,3,1,2,2] 。
总代价为 10 ，是所有方案中的最小代价。
```

**示例 3：**

```
输入：nums1 = [1,2,2], nums2 = [1,2,2]
输出：-1
解释：
不管怎么操作，都无法满足题目要求。
所以返回 -1 。
```

提示：

n == nums1.length == nums2.length
1 <= n <= 105
1 <= nums1[i], nums2[i] <= n

---

## 思维题 + 分类讨论

统计满足 x=nums1[i]=nums2[i] 的数对的个数 swapCnt，以及 x 的众数 mode 及其出现次数 modeCnt

分类讨论：

- 如果 modeCnt 没有超过 swapCnt 的一半：
  - 如果 swapCnt 是偶数，那么两两交换即可；
  - 如果 swapCnt 是奇数，那么至少有三种不同的 x，其中一个数必然可以和 nums1[0]交换；
  - 因此这种情况下，代价就是这些 x 的下标之和。
- 如果 modeCnt 超过 swapCnt 的一半，或者说modeCnt * 2 > swapCnt，根据鸽巢原理，无法通过重排这些数字，让数组不相等（因为还存在一些 mode 仍然相同）。这种情况必须不断寻找其他的满足 nums1[j] != nums2[j] 的数对，且数对中的数都不等于 mode，直到 modeCnt* 2 ≤ swapCnt 为止。为了让答案尽量小，应从左到右遍历数组。如果仍然无法满足要求，则返回 −1。

```python
class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        ans = swap_cnt = mode_cnt = mode = 0
        cnt = [0] * (len(nums1) + 1)
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y:
                ans += i
                swap_cnt += 1
                cnt[x] += 1
                if cnt[x] > mode_cnt:
                    mode_cnt, mode = cnt[x], x

        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if mode_cnt * 2 <= swap_cnt: break
            if x != y and x != mode and y != mode:
                ans += i
                swap_cnt += 1
        return ans if mode_cnt * 2 <= swap_cnt else -1
```

