[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

## 方法：指向各自集合的双指针

从后往前遍历，s_cnt 和 t_cnt 记录当前累计的 # 数量，i 和 j 指向各自集合的指针，**只有在同时到达 -1 时，返回 true**

一轮遍历定义为三部：

1、先遍历 s

- 如果 s_cnt 等于 0，且 i 指向字母时，这个字母就是需要比较的
- 如果 s_cnt 不等于 0，i 指向 # 时，s_cnt 加一
- 如果 s_cnt 不等于 0，i 指向字母时，s_cnt 减一

2、同理去遍历 t

- 如果 t_cnt 等于 0，且 j 指向字母时，这个字母就是需要比较的
- 如果 t_cnt 不等于 0，j 指向 # 时，t_cnt 加一
- 如果 t_cnt 不等于 0，j 指向字母时，t_cnt 减一

3、检查下，遍历完 s 和 t 后，i j 的位置

- 如果都大于等于 0，s[i] != t[j] 时，返回false，否则进行下一轮遍历
- 其中一个小于零 或 都小于零
  - **只有在同时到达 -1 时，返回 true**
  - 一个到了，另一个没到，返回 false

时间复杂度：`O(n)`

空间复杂度：`O(1)`

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i = s.length() - 1, j = t.length() - 1;
        int s_cnt = 0, t_cnt = 0;

        while (true) {
            while (i >= 0) {
                if (s_cnt == 0 && s[i] != '#') {
                    break;
                } else {
                    if (s[i] == '#') {
                        s_cnt++;
                    } else {
                        s_cnt--;
                    }
                    i--;
                }
            }
            while (j >= 0) {
                if (t_cnt == 0 && t[j] != '#') {
                    break;
                } else {
                    if (t[j] == '#') {
                        t_cnt++;
                    } else {
                        t_cnt--;
                    }
                    j--;
                }
            }
            if (i >= 0 && j >= 0) {  // 都大于等于0
                if (s[i] != t[j]) {
                    return false;
                }
            } else {                       // 其中一个小于零 或 都小于零
                if (i == -1 && j == -1) {  // 同时到达 -1 时，返回 True
                    return true;
                } else {
                    return false;
                }
            }
            i--, j--;
        }
        return true;  // 逻辑不会走到这里
    }
};
```

