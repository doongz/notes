# 二叉树的前序遍历：

class Solution:

    def preorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def helper(root):

            if not root:

                return

            res.append(root.val)

            helper(root.left)

            helper(root.right)

        helper(root)

        return res

class Solution:

    def preorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        if not root:

            return res

        stack = [root]

        while stack:

            node = stack.pop()

            res.append(node.val)

            if node.right:

                stack.append(node.right)

            if node.left:

                stack.append(node.left)

        return res

# 二叉树的中序遍历：

class Solution:

    def inorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def helper(root):

            if not root:

                return

            helper(root.left)

            res.append(root.val)

            helper(root.right)

        helper(root)

        return res

class Solution:

    def inorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        stack = []

        # 用p当做指针

        p = root

        while p or stack:

            # 把左子树压入栈中

            while p:

                stack.append(p)

                p = p.left

            # 输出 栈顶元素

            p = stack.pop()

            res.append(p.val)

            # 看右子树

            p = p.right

        return res

# 二叉树的后序遍历

class Solution:

    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def helper(root):

            if not root:

                return

            helper(root.left)

            helper(root.right)

            res.append(root.val)

        helper(root)

        return res

class Solution:

    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        if not root:

            return res

        stack = [root]

        while stack:

            node = stack.pop()

            if node.left :

                stack.append(node.left)

            if node.right:

                stack.append(node.right)

            res.append(node.val)

        return res[::-1]

# 二叉树的层次遍历

class Solution:

    def levelOrder(self, root):

        """

        :type root: TreeNode

        :rtype: List[List[int]]

        """

        if not root:

            return []

        res,cur_level = [],[root]

        while cur_level:

            temp = []

            next_level = []

            for i in cur_level:

                temp.append(i.val)

                if i.left:

                    next_level.append(i.left)

                if i.right:

                    next_level.append(i.right)

            res.append(temp)

            cur_level = next_level

        return res




