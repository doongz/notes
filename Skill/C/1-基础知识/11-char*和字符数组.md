# 深入 `char *` ,`char **`,`char a[]`,`char *a[]` 内核

来源：https://blog.csdn.net/daiyutage/article/details/8604720

C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑



### 1、数组的本质

数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素

### 2、指针的本质

指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。由于地址也是整数，在３２位平台下，指针默认为３２位

### 3、指针的指向

指针变量所保存的其他的地址单元中所存放的数据类型

```c
int *p ;	// p 变量保存的地址所在内存单元中的数据类型为整型
float *q;	// 浮点型
```

不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的是地址。

### 4、字符数组

字面意思是数组，数组中的元素是字符

```c
char str[10]; 					// 定义了一个有十个元素的数组，元素类型为字符
char str[10 = {"hello world"}; 	// C语言中定义一个变量时可以初始化。
```

当编译器遇到这句时，会把 `str` 数组中从第一个元素把 `hello world\0` 逐个填入

由于C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。

C语言中规定数组代表数组所在内存位置的首地址，也是 `str[0]` 的地址，即 `str = &str[0];`

而 `printf("%s",str);` 为什么用首地址就可以输出字符串？

因为还有一个关键，**在C语言中字符串常量的本质表示其实是一个地址**，这是许多初学者比较难理解的问题

举例：

```c
char *s;
s = "China";
```

为什么可以把一个字符串赋给一个指针变量？这不是类型不一致吗？这就是上面提到的关键

C语言中编译器会给字符串常量分配地址，如果 `"China"`, 存储在内存中的 `0x3000 0x3001 0x3002 0x3003 0x3004 0x3005`

`*s = "China";`，真正的意义是 `s ="China" = 0x3000;`

你把 `China` 看作是字符串，但是编译器把它看作是地址 `0x3000`，即字符串常量的本质表现是代表它的第一个字符的地址 `*s = 0x3000`

那么 `%s` ，它的原理其实也是通过字符串首地址输出字符串，`printf("%s ", s);`  传给它的其实是s所保存的字符串的地址

比如

```c
#include <stdio.h>

int main() {
  char *str= "hello world";

  printf("addr:%p, str:%s\n", str, str);
  printf("addr:%p, str:%s\n", str+1, str+1);
}
// addr:0x55b45bdcd734, str:hello world
// addr:0x55b45bdcd735, str:ello world
```

字符数组：` char str[10] = "hello";`

前面已经说了，`str = &str[0]` ， 也等于 `"hello"` 的首地址，所以 `printf("%s",str);` 本质也是 `printf("%s", 地址);`

**C语言中操作字符串是通过它在内存中的存储单元的首地址进行的，这是字符串的终极本质**

### 5、char * 与 char a[]

```c
char *s;
char a[];
```

前面说到 `a` 代表字符串的首地址，而 `s` 这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，这也与 `s` 所指向的 `char` 一致

因此可以 `s = a;`， 但是不能 `a = s;`

**C语言中数组名可以复制给指针表示地址， 但是却不能赋给给数组名，它是一个常量类型，所以不能修改**

当然也可以这样

```c
char a[] = "hello";
char *s = a;
for (int i = 0; i < strlen(a); i++) {
    printf("%c", s[i]);
    printf("%c", *s++);
}
```

字符指针可以用 间接操作符 `*` 取其内容，也可以用数组的下标形式 `[ ]`，数组名也可以用 `*` 操作，因为它本身表示一个地址

**`char *` 与 `char a[ ]` 的本质区别**：

当定义 `char a[10]` 时，编译器会给数组分配十个单元，每个单元的数据类型为字符

而定义 `char *s` 时， 这是个指针变量，只占四个字节，32位，用来保存一个地址

`sizeof(a) = 10`

`sizeof(s) = 4`，编译器分配4个字节32位的空间，这个空间中将要保存地址

`printf("%p",s);` 这个表示 s 的单元中所保存的地址

`printf("%p",&s);` 这个表示变量本身所在内存单元地址

用一句话来概括，就是 `char *s` 只是一个保存字符串首地址的指针变量， `char a[ ]` 是许多连续的内存单元，单元中的元素为 `char` 

之所以用 `char *`能达到 `char a []` 的效果，还是字符串的本质，地址，即给你一个字符串地址，便可以随心所欲的操所他。但是，`char *` 和 `char a[]` 的本质属性是不一样的

### 6、`char **` 与 `char *a[]`

**先看 `char *a [];`**

由于 `[]` 的优先级高于 `*` 所以 `a` 先和 `[]` 结合，他还是一个数组，数组中的元素才是 `char *` ，前面讲到 `char *` 是一个变量，保存的地址

所以 `char *a[ ] = {"China","French","America","German"};`

同过这句可以看到， 数组中的元素是字符串，那么 `sizeof(a)` 是多少呢，有人会想到是五个单词的占内存中的全部字节数 6+7+8+7 = 28

但是其实 `sizeof(a) = 16`

为什么，前面已经说到， 字符串常量的本质是地址，`a` 数组中的元素为 `char *` 指针，指针变量占四个字节，那么四个元素就是16个字节了

看一下实例：

```c
#include <stdio.h>

int main() {
  char *a[] = {"China", "French", "America", "German"};
  printf("%p %p %p %p\n", a[0], a[1], a[2], a[3]);
  return 0;
}

// 00422FB8 00422FB0 00422FD0 00422020
```

可以看到数组中的四个元素保存了四个内存地址，这四个地址中就代表了四个字符串的首地址，而不是字符串本身

注意这四个地址是不连续的，它是编译器为 `"China","French","America","German"` 分配的内存空间的地址， 所以，四个地址没有关联

```c
#include <stdio.h>

int main() {
  char *a[] = {"China", "French", "America", "German"};
  printf("%p %p %p %p\n", a[0], a[1], a[2], a[3]); // 数组元素中保存的地址
  printf("%p %p %p %p\n", &a[0], &a[1], &a[2], &a[3]); // 数组元素单元本身的地址
  return 0;
}

// 00422FB8 00422FB0 00422FD0 00422020
// 0012FF38 0012FF3C 0012FF40 0012FF44
```

可以看到 `0012FF38 0012FF3C 0012FF40 0012FF44`,这四个是元素单元所在的地址，每个地址相差四个字节，这是由于每个元素是一个指针变量占四个字节

**char **s;**

`char **` 为二级指针， `s` 保存一级指针 `char *` 的地址

```c
char *a[] = {"China", "French", "America", "German"};
char **s = a;
```

为什么能把 `a` 赋给 `s` ,因为数组名 `a` 代表数组元素内存单元的首地址，即 `a = &a[0] = 0012FF38;`

而 `0x12FF38` 即 `a[0]` 中保存的又是 `00422FB8` ,这个地址， `00422FB8` 为字符串 `"China"` 的首地址，即 `*s = 00422FB8 = "China";`

这样便可以通过s 操作 a 中的数据

```c
printf("%s", *s);
printf("%s", a[0]);
printf("%s", *a);
```

但还是要注意，不能 `a = s`，前面已经说到，`a` 是一个常量

再看一个易错的点： `char **s = "hello world";` 这样是错误的

因为 `s` 的类型是 `char **`  而 `"hello world"` 的类型是 `char *`

虽然都是地址， 但是指向的类型不一样，因此，不能这样用。从其本质来分析，`"hello world"`,代表一个地址，比如0x003001,这个地址中的内容是 `'h'` 为 `char` 型，而 `s` 也保存一个地址 ，这个地址中的内容`(*s)` 是`char *`　，是一个指针类型，所以两者类型是不一样的

如果是这样呢？

```c
char **S;
*s = "hello world";
```

貌似是合理的，编译也没有问题，但是 `printf("%s",*s)`,就会崩溃 why?

`printf("%s",*s);` 时，首先得有 `s` 保存的地址，再在这个地址中找到 `char *`  的地址，即 `*s`;

`s = 0x1000;` 在0x1000所在的内存单元中保存了"hello world"的地址 0x003001 ， `*s = 0x003001;`

这样`printf("%s",*s);` 这样会先找到 0x1000,然后找到0x003001;

如果直接 `char  **s;`，`*s = "hello world";`，s 变量中保存的是一个无效随机不可用的地址， 谁也不知道它指向哪里，`*s` 操作会崩溃

所以用 `char **s` 时，要给它分配一个内存地址。

```c
char **s;
s = (char **) malloc(sizeof(char**));
*s = "hello world";
```

这样 s 给分配了了一个可用的地址，比如 s = 0x412f;， 然后在 0x412f所在的内存中的位置，保存 "hello world"的值。

再如：

```c
#include <stdio.h>

void buf(char **s) {
  *s = "message";
}

int main() {
  char *s;
  buf(&s);
  printf("%s\n", s);
}
```

二级指针的简单用法，说白了，二级指针保存的是一级指针的地址，它的类型是指针变量，而一级指针保存的是指向数据所在的内存单元的地址，虽然都是地址，但是类型是不一样的