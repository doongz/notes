# ç†è§£å¹¶å‘ç¨‹åºæ‰§è¡Œ

## Overview

å¤ä¹ 

- å¹¶å‘ç¨‹åº = å¤šä¸ªæ‰§è¡Œæµã€å…±äº«å†…å­˜çš„çŠ¶æ€æœº

------

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: å¦‚ä½•é˜…è¯»ç†è§£æ•™ç§‘ä¹¦/äº’è”ç½‘/æœŸæœ«è¯•å·ä¸Šçš„å„ç§å¹¶å‘ç¨‹åºï¼Ÿ

------

æœ¬æ¬¡è¯¾ä¸»è¦å†…å®¹

- (è‡ªåŠ¨) ç”»çŠ¶æ€æœºç†è§£å¹¶å‘ç¨‹åº

## æ”¶è·

### 1ã€å¦‚ä½•ç†è§£å¹¶å‘ç¨‹åºï¼Ÿç”»çŠ¶æ€æœº

- å¹¶å‘ç¨‹åº = å¤šä¸ªæ‰§è¡Œæµã€å…±äº«å†…å­˜çš„çŠ¶æ€æœº
  - çº¿ç¨‹å…±äº«å†…å­˜
  - æ¯ä¸€æ­¥éç¡®å®šé€‰æ‹©çº¿ç¨‹æ‰§è¡Œ
- ç”»çŠ¶æ€æœºå°±å¯¹äº†ï¼Œå½“ç„¶ï¼Œç”¨å·¥å…·å¸®ä½ ç”» (model checker)

åŸåˆ™ä¸Šå¯ä»¥ç”¨çº¸å’Œç¬”å°†ç¨‹åºæ‰§è¡Œçš„ä»»ä½•çŠ¶æ€éƒ½ç”»å‡ºæ¥

åœ¨ç”»çŠ¶æ€æœºçš„è¿‡ç¨‹ä¸­ï¼Œå¯¹ç¨‹åºè¯­è¨€çš„å½¢å¼è¯­ä¹‰ã€å¹¶å‘ç®—æ³•çš„æ‰§è¡Œæœ‰ç¬¬ä¸€æ‰‹çš„è®¤è¯†

ä½†å¹¶å‘ç¼–ç¨‹æ¯”å¤§å®¶æƒ³è±¡å¾—å›°éš¾

### 2ã€(è‡ªåŠ¨) ç”»çŠ¶æ€æœºç†è§£å¹¶å‘ç¨‹åº

å¹¶å‘ç®—æ³•çš„è®¾è®¡å›°å¢ƒ

- ä¸æ•¢ä¸ç”»ï¼šè°çŸ¥é“æœ‰ä»€ä¹ˆå¥‡æ€ªæƒ…å†µä¼šå‘ç”Ÿï¼Ÿ
- ä¸æ•¢ä¹±ç”»ï¼šç”»é”™äº†å°±éƒ½å®Œäº†

å°±æ˜¯ **Model Checker** å’Œ å¯è§†åŒ–

> Model checking is a method for formally verifying finite-state systemsâ€”â€”åªè¦èƒ½ä¸ºç³»ç»Ÿå»ºç«‹æ¨¡å‹ï¼Œå°±èƒ½ç”¨ prove by brute-force è¯æ˜æ­£ç¡®/æ‰¾åˆ°é”™è¯¯ã€‚

Model checker çš„ä¸€åˆ‡å°±æ˜¯çŠ¶æ€æœºï¼

- Safety: æ²¡æœ‰çº¢è‰²èŠ‚ç‚¹ï¼Œçº¢è‰²çš„çŠ¶æ€ä¸å¯åˆ°è¾¾ï¼Œæ˜¯bug
  - G(V,E) ä¸Šçš„å¯è¾¾æ€§é—®é¢˜
- (Strong) Liveness: ä»ä»»æ„çŠ¶æ€å‡ºå‘ï¼Œéƒ½èƒ½åˆ°è¾¾ç»¿/è“è‰²çŠ¶æ€
  - G(V,E) ä¸Šçš„ä»€ä¹ˆé—®é¢˜ï¼Ÿä»é»‘è‰²èŠ‚ç‚¹å‡ºå‘ï¼Œé€šè¿‡ä¸€ä¸ªç¯ï¼Œè¿”å›è‡ªå·±ï¼ˆå¼ºè¿é€šåˆ†é‡è§£å†³ï¼‰

### 3ã€å·¥å…·çš„åŠ›é‡

> æ²¡æœ‰äººèƒ½é˜»æ­¢ç¨‹åºå‘˜å†™ bugï¼Œä½†å·¥å…·å¯ä»¥ã€‚

è‡³ä»Šä¸ºæ­¢æˆ‘ä»¬ç”¨è¿‡çš„è‡ªåŠ¨åŒ–å·¥å…· (ä»–ä»¬æ‹¯æ•‘äº†ä½ æ— æ•°æ¬¡)

- Type safety check
- `-Wall -Werror`
- Differential testing
- Model checker
- â€¦â€¦

------

è¿™é—¨è¯¾çš„å¦ä¸€ä¸ª take-away

- æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªå·¨å¤§çš„å·¥ç¨‹
- æ²¡æœ‰å·¥å…· (ç¼–ç¨‹ã€æµ‹è¯•ã€è°ƒè¯•â€¦â€¦)ï¼Œä¸åšç³»ç»Ÿ

## ä¸€ã€ç”»çŠ¶æ€æœºç†è§£å¹¶å‘ç¨‹åº

### 1ã€ä¸€ä¸ªäº’æ–¥ç®—æ³•

> äº’æ–¥ï¼šä¿è¯ä¸¤ä¸ªçº¿ç¨‹ä¸èƒ½åŒæ—¶æ‰§è¡Œä¸€æ®µä»£ç ã€‚
æ’å…¥ â€œç¥ç§˜ä»£ç â€ï¼Œä½¿å¾— [sum.c](http://jyywiki.cn/pages/OS/2022/demos/sum.c) (æˆ–è€…ä»»æ„å…¶ä»–ä»£ç ) èƒ½å¤Ÿæ­£å¸¸å·¥ä½œ

```c
void Tsum() {
  // ç¥ç§˜ä»£ç 
  sum++;
  // ç¥ç§˜ä»£ç 
}
```

- å‡è®¾ä¸€ä¸ªå†…å­˜çš„è¯»/å†™å¯ä»¥ä¿è¯é¡ºåºã€åŸå­å®Œæˆ

```c
__sync_synchronize();
x = 1; // æˆ– int t = x;
__sync_synchronize();
```

---

```c
#include "thread.h"
#define N 100000000
long sum = 0;
void Tsum() {
    for (int i = 0; i < N; i++) {
        sum++;
    }
}
int main() {
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```

```bash
$ gcc -O0 a.c && ./a.out 
sum = 101852382
$ gcc -O1 a.c && ./a.out 
sum = 200000000
$ gcc -O2 a.c && ./a.out 
sum = 200000000
```

é€šè¿‡ï¼šobjdump å‘½ä»¤å»çœ‹

```bash
$ gcc -O0 -c a.c && objdump -d a.o
$ gcc -O1 -c a.c && objdump -d a.o
```

### 2ã€å¤±è´¥çš„å°è¯•

```c
int locked = UNLOCK;

void critical_section() {
retry:
  if (locked != UNLOCK) {
    goto retry;
  }
  locked = LOCK;

  // critical section

  locked = UNLOCK;
}
```

å’Œå±±å¯¨ [alipay.c](http://jyywiki.cn/pages/OS/2022/demos/alipay.c) å®Œå…¨ä¸€æ ·çš„é”™è¯¯

- å¤„ç†å™¨é»˜è®¤ä¸ä¿è¯ load + store çš„åŸå­æ€§

é—®é¢˜çš„åŸå› åœ¨äºä¸‹é¢çš„è¯­å¥ï¼Œä¸æ˜¯åŸå­æ€§çš„

```c
  if (locked != UNLOCK) {
    goto retry;
  }
  locked = LOCK;
```

### 3ã€æ­£ç¡®æ€§ä¸æ˜çš„å¥‡æ€ªå°è¯• (Peterson ç®—æ³•)

A å’Œ B äº‰ç”¨å•æ‰€çš„åŒ…å¢

- æƒ³è¿›å…¥åŒ…å¢ä¹‹å‰ï¼ŒA/B éƒ½è¦å…ˆä¸¾èµ·è‡ªå·±çš„æ——å­
  - A ç¡®è®¤æ——å­ä¸¾å¥½ä»¥åï¼Œå¾€å•æ‰€é—¨ä¸Šè´´ä¸Š â€œB â€ çš„æ ‡ç­¾
  - B ç¡®è®¤æ——å­ä¸¾å¥½ä»¥åï¼Œå¾€å•æ‰€é—¨ä¸Šè´´ä¸Š â€œA â€ çš„æ ‡ç­¾
- ç„¶åï¼Œ**å¦‚æœå¯¹æ–¹çš„æ——å­ä¸¾èµ·æ¥ï¼Œä¸”é—¨ä¸Šçš„åå­—ä¸æ˜¯è‡ªå·±**ï¼Œç­‰å¾…
  - å¦åˆ™å¯ä»¥è¿›å…¥åŒ…å¢
- å‡ºåŒ…å¢åï¼Œæ”¾ä¸‹è‡ªå·±çš„æ——å­

---

Peterson ç®—æ³•æå‡ºäº†ä¸€ç§äº’æ–¥çš„åè®®ï¼Œå‚è€ƒ[Petersonç®—æ³• - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦ (wikipedia.org)](https://zh.m.wikipedia.org/zh-hans/Petersonç®—æ³•)

è¯¥ç®—æ³•æ»¡è¶³è§£å†³ä¸´ç•ŒåŒºé—®é¢˜çš„ä¸‰ä¸ªå¿…é¡»æ ‡å‡†ï¼šäº’æ–¥è®¿é—®, è¿›å…¥ï¼ˆå³ä¸æ­»é”ï¼‰, æœ‰é™ç­‰å¾…ï¼ˆå³ä¸é¥¿æ­»ï¼‰

```c
// flag[] is boolean array; and turn is an integer
flag[0]   = false;
flag[1]   = false;
int turn;

// P0: 
flag[0] = true;
turn = 1;
while (flag[1] == true && turn == 1)
{
    // busy wait
}
// critical section
...
// end of critical section
flag[0] = false;

// P1: 
flag[1] = true;
turn = 0;
while (flag[0] == true && turn == 0)
{
    // busy wait
}
// critical section
...
// end of critical section
flag[1] = false;
```

### 4ã€ä¹ é¢˜ï¼šè¯æ˜ Peterson ç®—æ³•æ­£ç¡®ï¼Œæˆ–ç»™å‡ºåä¾‹

è¿›å…¥ä¸´ç•ŒåŒºçš„æƒ…å†µ

- å¦‚æœåªæœ‰ä¸€ä¸ªäººä¸¾æ——ï¼Œä»–å°±å¯ä»¥ç›´æ¥è¿›å…¥
- å¦‚æœä¸¤ä¸ªäººåŒæ—¶ä¸¾æ——ï¼Œç”±å•æ‰€é—¨ä¸Šçš„æ ‡ç­¾å†³å®šè°è¿›
  - æ‰‹å¿« ğŸˆ¶ï¸ (è¢«å¦ä¸€ä¸ªäººçš„æ ‡ç­¾è¦†ç›–)ã€æ‰‹æ…¢ ğŸˆš

------

ä¸€äº›å…·ä½“çš„ç»†èŠ‚æƒ…å†µ

- A çœ‹åˆ° B æ²¡æœ‰ä¸¾æ——
  - B ä¸€å®šä¸åœ¨ä¸´ç•ŒåŒº
  - æˆ–è€… B æƒ³è¿›ä½†è¿˜æ²¡æ¥å¾—åŠæŠŠ â€œAâ€ è´´åœ¨é—¨ä¸Š
    - memory ordering
- A çœ‹åˆ° B ä¸¾æ——å­
  - A ä¸€å®šå·²ç»æŠŠæ——å­ä¸¾èµ·æ¥äº† (*!@^#*&!%^(&^!@%#

### 5ã€Prove by Brute-force!

æšä¸¾çŠ¶æ€æœºçš„å…¨éƒ¨çŠ¶æ€ (å‡è®¾æ²¡æœ‰ä¹±åºã€æ¯æ­¥æ‰§è¡Œä¸€è¡Œ)

- (PC1,PC2,x,y,turn); [peterson-simple.c](http://jyywiki.cn/pages/OS/2022/demos/peterson-simple.c)

```c
int x = 0, y = 0, turn = A;
void TA() {
    while (1) {
/* PC=1 */  x = 1;
/* PC=2 */  turn = B;
/* PC=3 */  while (y && turn == B) ;
            critical_section();
/* PC=4 */  x = 0; } }
void TB() {
  while (1) {
/* PC=1 */  y = 1;
/* PC=2 */  turn = A;
/* PC=3 */  while (x && turn == A) ;
            critical_section();
/* PC=4 */  y = 0; } }
```

åŸåˆ™ä¸Šå¯ä»¥ç”¨çº¸å’Œç¬”å°†ç¨‹åºæ‰§è¡Œçš„ä»»ä½•çŠ¶æ€éƒ½ç”»å‡ºæ¥

åœ¨ç”»çŠ¶æ€æœºçš„è¿‡ç¨‹ä¸­ï¼Œå¯¹ç¨‹åºè¯­è¨€çš„å½¢å¼è¯­ä¹‰ã€å¹¶å‘ç®—æ³•çš„æ‰§è¡Œæœ‰ç¬¬ä¸€æ‰‹çš„è®¤è¯†

![image-20220709203704901](./doc/image-20220709203704901.png)

```c
#include "thread.h"

#define A 1
#define B 2

atomic_int nested;
atomic_long count;

// è¿™ä¸ªå‡½æ•°åˆ¤æ–­ï¼Œæ˜¯ä¸æ˜¯ä»»ä½•æ—¶å€™åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨ä¸´ç•ŒåŒº
// çœ‹åˆ°è®¡æ•°å™¨ä¸º2çš„è¯ï¼Œè¯´æ˜æœ‰ä¸¤ä¸ªäººåœ¨ä¸´ç•ŒåŒºé‡Œ
void critical_section() {
  long cnt = atomic_fetch_add(&count, 1);
  assert(atomic_fetch_add(&nested, 1) == 0);
  atomic_fetch_add(&nested, -1);
}

int volatile x = 0, y = 0, turn = A;

void TA() {
    while (1) {
/* PC=1 */  x = 1;
/* PC=2 */  turn = B;
/* PC=3 */  while (y && turn == B) ;
            critical_section();
/* PC=4 */  x = 0;
    }
}

void TB() {
  while (1) {
/* PC=1 */  y = 1;
/* PC=2 */  turn = A;
/* PC=3 */  while (x && turn == A) ;
            critical_section();
/* PC=4 */  y = 0;
  }
}

int main() {
  create(TA);
  create(TB);
}
```

### 6ã€Peterson's Protocol Verified ğŸ–

> æˆ‘ä»¬ (åœ¨å®Œå…¨ä¸ç†è§£ç®—æ³•çš„å‰æä¸‹) è¯æ˜äº† Sequential å†…å­˜æ¨¡å‹ä¸‹ Peterson's Protocol çš„ Safetyã€‚å®ƒèƒ½å¤Ÿå®ç°äº’æ–¥ã€‚

å¹¶å‘ç¼–ç¨‹æ¯”å¤§å®¶æƒ³è±¡å¾—å›°éš¾

- æ„Ÿå—ä¸€ä¸‹ [dekker.py](http://jyywiki.cn/pages/OS/2022/demos/dekker.py)
- â€œ[Myths about the mutual exclusion problem](https://zoo.cs.yale.edu/classes/cs323/doc/Peterson.pdf)â€ (IPL, 1981)

å’Œä¸€äº›ç°çŠ¶

- ä»Šå¤©æœ‰éå¸¸åš (å†…) å® (å·) çš„ç†è®ºä½“ç³»
- å°å¿ƒç¼–è¯‘å™¨å’Œå¤šå¤„ç†å™¨ç¡¬ä»¶
  - æ›´å¥½çš„ peterson ç®—æ³•ï¼š[peterson-barrier.c](http://jyywiki.cn/pages/OS/2022/demos/peterson-barrier.c) (å“ªäº› barrier æ˜¯å¤šä½™çš„å—ï¼Ÿ)

---

```bash
$ gcc peterson-barrier.c -lpthread && ./a.out
```

æŠŠæ¯ä¸€æ­¥å†…å­˜è®¿é—®éƒ½æ‹†å¼€äº†

åœ¨æ¯ä¸ªä¸€å†…å­˜è®¿é—®çš„è¾¹ç•Œä¸Šéƒ½å¢åŠ äº† `BARRIER`

- æ—¢æ˜¯ compiler barrierï¼Œä¸å…è®¸ç¼–è¯‘å™¨éšæ„ re-order å†…å­˜è®¿é—®
- è¿˜æ˜¯ memory barrierï¼Œè¿è¡Œå¾ˆé•¿æ—¶é—´çš„è¯ï¼Œä¹Ÿä¸ä¼šå‡ºé—®é¢˜

```c
#include "thread.h"

#define A 1
#define B 2

#define BARRIER __sync_synchronize()

atomic_int nested;
atomic_long count;

void critical_section() {
  long cnt = atomic_fetch_add(&count, 1);
  int i = atomic_fetch_add(&nested, 1) + 1;
  if (i != 1) {
    printf("%d threads in the critical section @ count=%ld\n", i, cnt);
    assert(0);
  }
  atomic_fetch_add(&nested, -1);
}

int volatile x = 0, y = 0, turn;

void TA() {
  while (1) {
    x = 1;                   BARRIER;
    turn = B;                BARRIER; // <- this is critcal for x86
    while (1) {
      if (!y) break;         BARRIER;
      if (turn != B) break;  BARRIER;
    }
    critical_section();
    x = 0;                   BARRIER;
  }
}

void TB() {
  while (1) {
    y = 1;                   BARRIER;
    turn = A;                BARRIER;
    while (1) {
      if (!x) break;         BARRIER;
      if (turn != A) break;  BARRIER;
    }
    critical_section();
    y = 0;                   BARRIER;
  }
}

int main() {
  create(TA);
  create(TB);
}
```

## äºŒã€(è‡ªåŠ¨) ç”»çŠ¶æ€æœºç†è§£å¹¶å‘ç¨‹åº

### 1ã€ç”»çŠ¶æ€æœºå®åœ¨å¤ªç´¯äº†

å¹¶å‘ç®—æ³•çš„è®¾è®¡å›°å¢ƒ

- ä¸æ•¢ä¸ç”»ï¼šè°çŸ¥é“æœ‰ä»€ä¹ˆå¥‡æ€ªæƒ…å†µä¼šå‘ç”Ÿï¼Ÿ
- ä¸æ•¢ä¹±ç”»ï¼šç”»é”™äº†å°±éƒ½å®Œäº†

------

è§£å†³å›°å¢ƒ ğŸ’¡

- èƒ½ä¸èƒ½è®©ç”µè„‘å¸®æˆ‘ä»¬ç”»ï¼Ÿ
- æˆ‘ä»¬æœ‰ç¨‹åºçš„å½¢å¼è¯­ä¹‰ (æ•°å­¦å®šä¹‰)ï¼Œå°±èƒ½å†™è§£é‡Šå™¨æ¨¡æ‹Ÿæ‰§è¡Œï¼ˆnemuï¼‰
  - è¯´èµ·æ¥å®¹æ˜“ï¼Œä½†éœ€è¦å†™å¤šå°‘ä»£ç å‘¢â€¦â€¦ï¼Ÿ

### 2ã€å¹´è½»äººçš„ç¬¬ä¸€ä¸ª Model Checker

é€‰æ‹©æ­£ç¡®çš„è¯­è¨€

- å½“ç„¶æ˜¯ Python å•¦
- å®¹æ˜“ hack çš„åŠ¨æ€è¯­è¨€
- ä¸°å¯Œçš„åº“å‡½æ•°

é€‰æ­£ç¡®çš„è¯­è¨€æœºåˆ¶ï¼Œç”¨ c æˆ–è€… c++ å®ç°å°±æ˜¯ç»™è‡ªå·±æŒ–å‘

- æ¨¡å¼æ£€æŸ¥å™¨ï¼š[model-checker.py](http://jyywiki.cn/pages/OS/2022/demos/model-checker.py)ï¼Œä¼šéå†æ¨¡å‹ä¸Šæ‰€æœ‰å¯èƒ½çš„çŠ¶æ€
  - ~~ä»£ç é‡è¾¾åˆ°äº†æƒŠäººçš„ 150 è¡Œ~~ï¼
  - UNIX Philosophy: å†™èƒ½åˆä½œçš„ç¨‹åº
    - Model checker åªè´Ÿè´£è¾“å‡º â€œçŠ¶æ€å›¾â€
- å¯è§†åŒ–ï¼š[visualize.py](http://jyywiki.cn/pages/OS/2022/demos/visualize.py)

````bash
python3.7 -m pip install astor
python3.7 model-checker.py mutex-bad.py
...
````

```
brew install graphviz
pip3 install graphviz
pip3 install jinja2
pip3 install markdown
```



model-checker.py:

ä¸€å®šè¦ç”¨ 3.7 ä»¥ä¸Šçš„ç‰ˆæœ¬æ‰è¡Œï¼Œ3.6.9 äº²æµ‹ä¸è¡Œ

```python
import inspect, ast, astor, copy, sys
from pathlib import Path

threads, marker_fn = [], []

def thread(fn):
    '''Decorate a member function as a thread'''
    global threads
    threads.append(fn.__name__)
    return fn

def marker(fn):
    '''Decorate a member function as a state marker'''
    global marker_fn
    marker_fn.append(fn)

def localvar(s, t, varname):
    '''Return local variable value of thread t in state s'''
    return s.get(t, (0, {}))[1].get(varname, None)

def checkpoint():
    '''Instrumented `yield checkpoint()` goes here'''
    f = inspect.stack()[1].frame # stack[1] is the caller of checkpoint()
    return (f.f_lineno, { k: v for k, v in f.f_locals.items() if k != 'self' })

def hack(Class):
    '''Hack Class to instrument @mc.thread functions'''
    class Instrument(ast.NodeTransformer):
        def generic_visit(self, node, in_fn=False):
            if isinstance(node, ast.FunctionDef):
                if node.name in threads:
                    # a @mc.thread function -> instrument it
                    in_fn, node.decorator_list = True, []
                elif node.decorator_list:
                    # a decorated function like @mc.mark -> remove it
                    return None

            body = []
            for line in getattr(node, 'body', []):
                # prepend each line with `yield checkpoint()`
                if in_fn: body.append(
                    ast.Expr(ast.Yield(
                        ast.Call(func=ast.Name(checkpoint.__name__, ctx=ast.Load()),
                            args=[], keywords=[]))) )
                body.append(self.generic_visit(line, in_fn))
            node.body = body
            return node

    if not hasattr(Class, 'hacked'):
        hacked_ast = Instrument().visit(ast.parse(Class.source))
        hacked_src, vars = astor.to_source(hacked_ast), {}
        # set a breakpoint() here to see **magic happens**!
        exec(hacked_src, globals(), vars)
        Class.hacked, Class.hacked_src = vars[Class.__name__], hacked_src
    return Class

def execute(Class, trace):
    '''Execute trace (like [0,0,0,2,2,1,1,1]) on Class'''
    def attrs(obj):
        for attr in dir(obj):
            val = getattr(obj, attr)
            if not attr.startswith('__') and type(val) in [bool, int, str, list, tuple, dict]:
                yield attr, val

    obj = hack(Class).hacked()
    for attr, val in attrs(obj):
        setattr(obj, attr, copy.deepcopy(val))
 
    T = []
    for t in threads:
        fn = getattr(obj, t)
        T.append(fn()) # a generator for a thread
    S = { t: T[i].__next__() for i, t in enumerate(threads) }

    while trace:
        chosen, tname, trace = trace[0], threads[trace[0]], trace[1:]
        try:
            if T[chosen]:
                S[tname] = T[chosen].__next__()
        except StopIteration:
            S.pop(tname)
            T[chosen] = None

    for attr, val in attrs(obj):
        S[attr] = val
    return obj, S

class State:
    def __init__(self, Class, trace):
        self.trace = trace
        self.obj, self.state = execute(Class, trace)
        self.name = f's{abs(State.freeze(self.state).__hash__())}'

    @staticmethod
    def freeze(obj):
        '''Create an object's hashable frozen (immutable) counterpart'''
        if obj is None or type(obj) in [str, int, bool]:
            return obj
        elif type(obj) in [list, tuple]:
            return tuple(State.freeze(x) for x in obj)
        elif type(obj) in [dict]:
            return tuple(sorted(
                zip(obj.keys(), (State.freeze(v) for v in obj.values()))
            ))
        raise ValueError('Cannot freeze')

def serialize(Class, s0, vertices, edges):
    '''Serialize all model checking results'''
    print(f'CLASS({repr(Class.hacked_src)})')

    sid = { s0.name: 0 }
    def name(s):
        if s.name not in sid: 
            sid[s.name] = len(sid)
        return repr(f's{sid[s.name]}')

    for u in vertices.values():
        mk = [f(u.obj, u.state) for f in marker_fn if f(u.obj, u.state)]
        print(f'STATE({name(u)}, {repr(u.state)}, {repr(mk)})')

    for u, v, chosen in edges:
        print(f'TRANS({name(u)}, {name(v)}, {repr(threads[chosen])})')

def check_bfs(Class):
    '''Enumerate all possible thread interleavings of @mc.thread functions'''
    s0 = State(Class, trace=[])

    # breadth-first search to find all possible thread interleavings
    queue, vertices, edges = [s0], {s0.name: s0}, []
    while queue:
        u, queue = queue[0], queue[1:]
        for chosen, _ in enumerate(threads):
            v = State(Class, u.trace + [chosen])
            if v.name not in vertices:
                queue.append(v)
                vertices[v.name] = v
            edges.append((u, v, chosen))

    serialize(Class, s0, vertices, edges)

src, vars = Path(sys.argv[1]).read_text(), {}
exec(src, globals(), vars)
Class = [C for C in vars.values() if type(C) == type].pop()
setattr(Class, 'source', src)
check_bfs(Class)

```

visualize.py:

```python
import sys, re, graphviz, jinja2, json, markdown, argparse
from pathlib import Path
from collections import namedtuple

EMPTY = 'â¡'
COLORS = { None: '#f1f5f9',
    'red': '#fecaca',
    'yellow': '#fef08a',
    'green': '#bbf7d0',
    'blue': '#bfdbfe',
    'purple': '#e9d5ff'
} 

Vertex = namedtuple('Vertex', 'name state marks')
Edge = namedtuple('Edge', 'name u v t')
State = namedtuple('State', 'pcs lvars gvars')

vertices, edges, threads = {}, [], []
code_lines, pcmap, gvar, lvar = [], {}, [], []

def parse_input():
    def CLASS(cl):
        global hacked_src
        hacked_src = cl
    
    def STATE(u, state, marks):
        vertices[u] = Vertex(name=u, state=state, marks=marks)
    
    def TRANS(u, v, t):
        edges.append(Edge(name=f'{u}-{v}', u=vertices[u], v=vertices[v], t=t))
        if t not in threads:
            threads.append(t)
    
    for line in sys.stdin.readlines():
        eval(line)

def parse_src():
    md_lines = ['    :::python']
    for line in hacked_src.splitlines():
        if 'yield' not in line:
            md_lines.append(f'    {line.replace("    ", "  ")}')
    html = markdown.markdown('\n'.join(md_lines), extensions=['codehilite'])
    code_lines.extend(re.search(r'<code.*?>(.*)</code>', html, re.DOTALL).group(1).rstrip().splitlines())

    new_pc = 0
    for pc, line in enumerate(hacked_src.splitlines()):
        if 'yield' not in line:
            pcmap[pc + 1] = (new_pc := new_pc + 1)

def parse_vars():
    gv, lv = set(), set()
    for v in vertices.values():
        for t, val in v.state.items():
            if t not in threads: gv.add(t)
            else: lv |= set((t, var) for var in val[1])
    gvar.extend(sorted(list(gv)))
    lvar.extend(sorted(list(lv)))

def parse_state(s):
    gvars = [s[g] for g in gvar]
    lvars = ['âŠ¥' for _ in enumerate(lvar)]
    pcs = [-1 for _ in enumerate(threads)]

    for t in [t for t in threads if t in s]:
        tpc, tstate = s[t]
        pcs[threads.index(t)] = pcmap[tpc + 1]
        for vname, val in tstate.items():
            lvars[lvar.index((t, vname))] = val

    return State(pcs, lvars, gvars)

def reduce(tree_only=False):
    tree, depth, leaf = [], {'s0' : 0}, {'s0': True}
    updated, rnd = 0, 0
    while updated + len(threads) > rnd:
        rnd += 1
        def expand():
            found = False
            for e in edges:
                _, u, v, t = e
                if u.name in depth and v.name not in depth and t == threads[-rnd % len(threads)]:
                    depth[v.name] = depth[u.name] + 1
                    leaf[v.name] = True
                    leaf[u.name] = False
                    tree.append(e)
                    found = True
            return found
        while expand():
            updated = rnd

    others = []
    if not tree_only:
        tnames = set(e.name for e in tree)
        for e in edges:
            name, u, v, t = e
            if name not in tnames:
                w = filter(lambda e1: e1.v.name == u.name, edges).__next__()
                if (leaf[e.u.name] and w.t == e.t) or (depth[u.name] >= depth[v.name]):
                    others.append(e)
    return tree, others

parse_input()
parse_src()
parse_vars()

parser = argparse.ArgumentParser(description='Visualize modeler checker outputs')
parser.add_argument('--tree', '-t', help='Draw tree', action='store_true')
parser.add_argument('--reduce', '-r', help='Draw reduced graph', action='store_true')
args = parser.parse_args()

if args.reduce or args.tree:
    edges, others = reduce(args.tree)
else:
    edges, others = edges, []

COLORS |= dict(zip(threads, ['#be123c', '#1d4ed8', '#eab308', '#4d7c0f']))

g = graphviz.Digraph('G', filename='/tmp/a.gv',
    graph_attr={ 'fontsize': '12', 'layout': 'dot', 'nodesep': '0.75' })
metadata = { 's0': vertices['s0'].name }

with g.subgraph(name='legend') as c:
    c.node_attr = { 'style': 'filled', 'fontname': 'Courier New', 'shape': 'Mrecord' }

    # draw vertices and code blocks
    for v in vertices.values():
        ps = parse_state(v.state)
        color = ([None] + [col for col in v.marks if col])[-1]

        gvals, lvals = '| '.join([f'{g}={v.state[g]}' for g in gvar]), ''
        for i, t in enumerate(threads):
            if i != 0: lvals += '|'
            lvals += '{' + '| '.join([f'{t}.{l}={v.state.get(t, (0, {}))[1].get(l, EMPTY)}' for t1, l in lvar if t1 == t]) + '}'
        label = '{' + '{' + gvals + '}' + '|' + '{' + lvals + '}' + '}'
        label = label.replace('True', 'T').replace('False', 'F')
        c.node(v.name, id=v.name, label=label, fillcolor=COLORS.get(color, color))

        lines = [ '<div class="codehilite">']
        for i, line in enumerate(code_lines):
            cl = 'new' if i + 1 in ps.pcs else ''
            lines.append(f'<pre class="{cl}"><code>{line if line else " "}</pre></code>')
        lines.append('<div class="vars">')
        for i, nm in enumerate(gvar):
            lines.append(f'<pre><code>{nm} = {ps.gvars[i]}</code></pre>')
        for i, (t, nm) in enumerate(lvar):
            lines.append(f'<pre><code>{t}.{nm} = {ps.lvars[i]}</code></pre>')
        lines.append('</div></div>')
        metadata[v.name] = '\n'.join(lines)

    # draw edges
    for idx, (name, u, v, t) in enumerate(edges + others):
        ps_old, ps_new = parse_state(u.state), parse_state(v.state)
        c.edge(u.name, v.name, id=name, fontcolor=COLORS[t], color=COLORS[t], label=t, fontname='Helvetica')

        diff = lambda x, y: f'<span class="new">{y}</span> <span class="old">({x})</span>' if x != y else x
        lines = [ '<div class="codehilite">']
        for i, line in enumerate(code_lines):
            if i + 1 in ps_new.pcs: cl = 'new'
            elif i + 1 in ps_old.pcs: cl = 'old'
            else: cl = ''
            lines.append(f'<pre class="{cl}"><code>{line if line else " "}</pre></code>')
        lines.append('<div class="vars">')
        for i, nm in enumerate(gvar):
            lines.append(f'<pre><code>{nm} = {diff(ps_old.gvars[i], ps_new.gvars[i])}</code></pre>')
        for i, (tname, nm) in enumerate(lvar):
            lines.append(f'<pre><code>{tname}.{nm} = {diff(ps_old.lvars[i], ps_new.lvars[i])}</code></pre>')
        lines.append('</div></div>')
        metadata[name] = '\n'.join(lines)

TEMPLATE = '''
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
        margin: 0; padding: 8px 16px; box-sizing: border-box;
        overflow: hidden;
      }
      #container {
        overflow: auto;
        width: 100%;
        height: 100%;
        position: absolute;
      }
      .codehilite {
        padding: 10px;
      }
      .old {
        background-color: #d4d4d4;
        opacity: 0.5;
      }
      .new {
        background-color: #f0abfc;
      }
      #code {
        font-size: 135%;
        border: 1px solid;
        top: 0;
        right: 0;
        width: 500px;
        position: absolute;
        float: right;
        background: white;
      }
      .vars {
        position: absolute;
        float: right;
        top: 5px; right: 505px;
        text-align: right;
        background-color: white;
        padding: 5px;
      }
      #mouse-circle {
        position: absolute;
        width: 32px;
        height: 32px;
        margin: -16px 0 0 -16px;
        border: 1px solid green;
        background-color: rgba(0, 255, 0, 0.5);
        border-radius: 50%;
        pointer-events: none;
        box-shadow: rgba(0, 255, 0, 0.35) 0px 5px 15px;
      }

      pre { line-height: 125%; margin: 0; }
      td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
      span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
      td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
      span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
      .codehilite .hll { background-color: #ffffcc }
      .codehilite .c { color: #177500 } /* Comment */
      .codehilite .err { color: #000000 } /* Error */
      .codehilite .k { color: #A90D91 } /* Keyword */
      .codehilite .l { color: #1C01CE } /* Literal */
      .codehilite .n { color: #000000 } /* Name */
      .codehilite .o { color: #000000 } /* Operator */
      .codehilite .ch { color: #177500 } /* Comment.Hashbang */
      .codehilite .cm { color: #177500 } /* Comment.Multiline */
      .codehilite .cp { color: #633820 } /* Comment.Preproc */
      .codehilite .cpf { color: #177500 } /* Comment.PreprocFile */
      .codehilite .c1 { display: none; color: #177500 } /* Comment.Single */
      .codehilite .cs { color: #177500 } /* Comment.Special */
      .codehilite .kc { color: #A90D91 } /* Keyword.Constant */
      .codehilite .kd { color: #A90D91 } /* Keyword.Declaration */
      .codehilite .kn { color: #A90D91 } /* Keyword.Namespace */
      .codehilite .kp { color: #A90D91 } /* Keyword.Pseudo */
      .codehilite .kr { color: #A90D91 } /* Keyword.Reserved */
      .codehilite .kt { color: #A90D91 } /* Keyword.Type */
      .codehilite .ld { color: #1C01CE } /* Literal.Date */
      .codehilite .m { color: #1C01CE } /* Literal.Number */
      .codehilite .s { color: #C41A16 } /* Literal.String */
      .codehilite .na { color: #836C28 } /* Name.Attribute */
      .codehilite .nb { color: #A90D91 } /* Name.Builtin */
      .codehilite .nc { color: #3F6E75 } /* Name.Class */
      .codehilite .no { color: #000000 } /* Name.Constant */
      .codehilite .nd { color: #000000 } /* Name.Decorator */
      .codehilite .ni { color: #000000 } /* Name.Entity */
      .codehilite .ne { color: #000000 } /* Name.Exception */
      .codehilite .nf { color: #000000 } /* Name.Function */
      .codehilite .nl { color: #000000 } /* Name.Label */
      .codehilite .nn { color: #000000 } /* Name.Namespace */
      .codehilite .nx { color: #000000 } /* Name.Other */
      .codehilite .py { color: #000000 } /* Name.Property */
      .codehilite .nt { color: #000000 } /* Name.Tag */
      .codehilite .nv { color: #000000 } /* Name.Variable */
      .codehilite .ow { color: #000000 } /* Operator.Word */
      .codehilite .mb { color: #1C01CE } /* Literal.Number.Bin */
      .codehilite .mf { color: #1C01CE } /* Literal.Number.Float */
      .codehilite .mh { color: #1C01CE } /* Literal.Number.Hex */
      .codehilite .mi { color: #1C01CE } /* Literal.Number.Integer */
      .codehilite .mo { color: #1C01CE } /* Literal.Number.Oct */
      .codehilite .sa { color: #C41A16 } /* Literal.String.Affix */
      .codehilite .sb { color: #C41A16 } /* Literal.String.Backtick */
      .codehilite .sc { color: #2300CE } /* Literal.String.Char */
      .codehilite .dl { color: #C41A16 } /* Literal.String.Delimiter */
      .codehilite .sd { color: #C41A16 } /* Literal.String.Doc */
      .codehilite .s2 { color: #C41A16 } /* Literal.String.Double */
      .codehilite .se { color: #C41A16 } /* Literal.String.Escape */
      .codehilite .sh { color: #C41A16 } /* Literal.String.Heredoc */
      .codehilite .si { color: #C41A16 } /* Literal.String.Interpol */
      .codehilite .sx { color: #C41A16 } /* Literal.String.Other */
      .codehilite .sr { color: #C41A16 } /* Literal.String.Regex */
      .codehilite .s1 { color: #C41A16 } /* Literal.String.Single */
      .codehilite .ss { color: #C41A16 } /* Literal.String.Symbol */
      .codehilite .bp { color: #5B269A } /* Name.Builtin.Pseudo */
      .codehilite .fm { color: #000000 } /* Name.Function.Magic */
      .codehilite .vc { color: #000000 } /* Name.Variable.Class */
      .codehilite .vg { color: #000000 } /* Name.Variable.Global */
      .codehilite .vi { color: #000000 } /* Name.Variable.Instance */
      .codehilite .vm { color: #000000 } /* Name.Variable.Magic */
      .codehilite .il { color: #1C01CE } /* Literal.Number.Integer.Long */
    </style>
  </head>
  
  <body>
    <div id="container" data-pan-on-drag data-zoom-on-wheel="min-scale: 0.3; max-scale: 16;">{{ svg }}</div>
    <div id="code"></div>
    <div id="mouse-circle"> </div>

    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom-container@0.5.1"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script> data = {{ data }}; </script> 
  
    <script>
      $(document).ready(function() {
        $("title").remove();
        $("#code").html(data[data["s0"]]);
        var disp = function() {
          var id = $(this).attr("id");
          var code = data[id];
          $("#code").html(code);
        };
        $(".node").mouseover(disp);
        $(".edge").mouseover(disp);
        $(".edge").css('cursor', 'none');
        $(".node").css('cursor', 'none');
      });
  
      document.addEventListener('DOMContentLoaded', () => {
        let mousePosX = 0, mousePosY = 0, mouseCircle = document.getElementById('mouse-circle');
        document.onmousemove = (e) => { mousePosX = e.pageX; mousePosY = e.pageY; }
        let delay = 6, revisedMousePosX = 0, revisedMousePosY = 0;
    
        function delayMouseFollow() {
          requestAnimationFrame(delayMouseFollow);
          revisedMousePosX += (mousePosX - revisedMousePosX) / delay;
          revisedMousePosY += (mousePosY - revisedMousePosY) / delay; 
          mouseCircle.style.top = revisedMousePosY + 'px';
          mouseCircle.style.left = revisedMousePosX + 'px';
        }
        delayMouseFollow();
      });
    </script>
  </body>
</html>
'''

svg_file = Path(g.render(format='svg'))
html = jinja2.Template(TEMPLATE).render(svg=svg_file.read_text(), data=json.dumps(metadata))
print(html)

```

### 3ã€model-checker å’Œ visualize çš„å¨åŠ›

- è¯•è¯•å¨åŠ›ï¼š[mutex-bad.py](http://jyywiki.cn/pages/OS/2022/demos/mutex-bad.py), [peterson-flag.py](http://jyywiki.cn/pages/OS/2022/demos/peterson-flag.py), [dekker.py](http://jyywiki.cn/pages/OS/2022/demos/dekker.py)
  - æˆ‘ä»¬çš„è¾“å‡ºæ ¼å¼æœ‰ä»€ä¹ˆç‰¹åˆ«çš„ç”¨æ„å—ï¼Ÿ

```bash
STATE('s0', {'t1': (5, {}), 't2': (21, {}), 'locked': ''}, [])
STATE('s1', {'t1': (7, {}), 't2': (21, {}), 'locked': ''}, [])
STATE('s2', {'t1': (5, {}), 't2': (23, {}), 'locked': ''}, [])
STATE('s3', {'t1': (11, {}), 't2': (21, {}), 'locked': ''}, [])
STATE('s4', {'t1': (7, {}), 't2': (23, {}), 'locked': ''}, [])
STATE('s5', {'t1': (5, {}), 't2': (27, {}), 'locked': ''}, [])
STATE('s6', {'t1': (13, {}), 't2': (21, {}), 'locked': 'ğŸ”’'}, [])
```

å› ä¸ºï¼Œ`model-checker` çš„è¾“å‡ºæ˜¯ç»™ç¨‹åºè¯»çš„

ã€1:06:19 å¾€åçœ‹ã€‘

```
>>> s = "STATE('s0', {'t1': (5, {}), 't2': (21, {}), 'locked': ''}, [])"
>>> STATE = lambda x,y,z:print(x,y,z)
>>> eval(s)
s0 {'t1': (5, {}), 't2': (21, {}), 'locked': ''} []
```

`eval()` å‡½æ•°æ‰§è¡Œå­—ç¬¦ä¸²

```bash
$ python model-checker.py mutex-bad.py | python visualize.py > a.html
$ python model-checker.py mutex-bad.py | python visualize.py -t > a.html
```

çº¢è‰²çš„èŠ‚ç‚¹æ˜¯æœ‰bugçš„





---

mutex-bad.py

```python
class Mutex:
    locked = '' # releaseçŠ¶æ€

    @thread # ç”¨è£…é¥°å™¨æ ‡è®°è¿™æ˜¯ä¸ªçº¿ç¨‹
    def t1(self):
        while True:
            while self.locked == 'ğŸ”’':
                pass
            self.locked = 'ğŸ”’' # lockçŠ¶æ€
            cs = True
            del cs
            self.locked = ''

    @thread
    def t2(self):
        while True:
            while self.locked == 'ğŸ”’':
                pass
            self.locked = 'ğŸ”’'
            cs = True
            del cs
            self.locked = ''
    
    # ä¸‹é¢æ˜¯æ ‡è®°çŠ¶æ€ç”¨çš„
    @marker
    def mark_t1(self, state):
        if localvar(state, 't1', 'cs'): return 'blue'

    @marker
    def mark_t2(self, state):
        if localvar(state, 't2', 'cs'): return 'green'

    @marker
    def mark_both(self, state):
        if localvar(state, 't1', 'cs') and localvar(state, 't2', 'cs'):
            return 'red'

```

peterson-flag.pyï¼š

```python
class Peterson:
    flag = '  '
    turn = ' '

    @thread
    def t1(self):
        while True:
            self.flag = 'ğŸ´' + self.flag[1]
            self.turn = 'ğŸ³'
            while self.flag[1] != ' ' and self.turn == 'ğŸ³':
                pass
            cs = True
            del cs
            self.flag = ' ' + self.flag[1]

    @thread
    def t2(self):
        while True:
            self.flag = self.flag[0] + 'ğŸ³'
            self.turn = 'ğŸ´'
            while self.flag[0] != ' ' and self.turn == 'ğŸ´':
                pass
            cs = True
            del cs
            self.flag = self.flag[0] + ' '

    @marker
    def mark_t1(self, state):
        if localvar(state, 't1', 'cs'): return 'blue'

    @marker
    def mark_t2(self, state):
        if localvar(state, 't2', 'cs'): return 'green'

    @marker
    def mark_both(self, state):
        if localvar(state, 't1', 'cs') and localvar(state, 't2', 'cs'):
            return 'red'

```

dekker.pyï¼š

```python
class Dekker:
    flag = [False, False]
    turn = 0

    @thread
    def t1(self):
        this, another = 0, 1
        while True:
            self.flag[this] = True
            while self.flag[another]:
                if self.turn == another:
                    self.flag[this] = False
                    while self.turn == another:
                        pass
                    self.flag[this] = True
            cs = True
            del cs
            self.turn = another
            self.flag[this] = False
  

    @thread
    def t2(self):
        this, another = 1, 0
        while True:
            self.flag[this] = True
            while self.flag[another]:
                if self.turn == another:
                    self.flag[this] = False
                    while self.turn == another:
                        pass
                    self.flag[this] = True
            cs = True
            del cs
            self.turn = another
            self.flag[this] = False

    @marker
    def mark_t1(self, state):
        if localvar(state, 't1', 'cs'): return 'blue'

    @marker
    def mark_t2(self, state):
        if localvar(state, 't2', 'cs'): return 'green'

    @marker
    def mark_both(self, state):
        if localvar(state, 't1', 'cs') and localvar(state, 't2', 'cs'):
            return 'red'

```

### 4ã€ä»£ç å¯¼è¯»ï¼šPython Generator

```python
def numbers(init=0, step=1):
    n = init
    while True:
        n += step
        yield n
```

```
>>> g = numbers()
>>> g
<generator object numbers at 0x107f873c0>
>>> g.__next__()
1
>>> g.__next__()
2
```

### 5ã€Generator: ä¹Ÿæ˜¯çŠ¶æ€æœº

`g = numbers()` æ˜¯ä¸€ä¸ªçŠ¶æ€æœº (ç±»ä¼¼æ˜¯çº¿ç¨‹ï¼Œä½†ä¸å¹¶å‘æ‰§è¡Œ)

- `g.__next__()` ä¼šåˆ‡æ¢åˆ°çŠ¶æ€æœºæ‰§è¡Œï¼Œç›´åˆ° `yield`
- çŠ¶æ€æœºè¿”å›ä¼šè§¦å‘ `StopIteration` å¼‚å¸¸



C ä¸­ï¼Œå‡½æ•°è°ƒç”¨äº†ï¼Œå¿…é¡»ç­‰åˆ°å‡½æ•°è¿”å›ï¼Œæ‰èƒ½å‡ºæ¥

pythonä¸­

- å‡½æ•°è°ƒç”¨äº†ï¼Œå‡½æ•°è¿”å›ï¼ŒçŠ¶æ€è¿˜åœ¨ï¼Œè¿˜å¯ä»¥å†è¿›æ¥å†å‡ºå»
- å¯åœ¨ç¨‹åºä¸­åˆ›å»ºä»»æ„å¤šçš„çŠ¶æ€æœºï¼Œå¯æ¨¡æ‹Ÿç¨‹åºçš„å¹¶å‘æ‰§è¡Œ
- è¿˜æ˜¯å…±äº«å†…å­˜çš„

```
>>> t1 = numbers()
>>> t2 = numbers()
>>> t1.__next__()
>>> t2.__next__()
```

------

åœ¨ C è¯­è¨€é‡ŒåŒæ ·å¯ä»¥å®ç° (MiniLab 2)

- åªè¦ä¸ºçŠ¶æ€æœºåˆ†é…æ ˆç©ºé—´å’Œå¯„å­˜å™¨å³å¯
- `yield()` åˆ‡æ¢åˆ°å¦å¤–çš„çŠ¶æ€æœº/çº¿ç¨‹æ‰§è¡Œ

### 6ã€Model Checker: å®ç°

```python
class Mutex:
    locked = ''

    def T1(self):
        yield checkpoint() # æŠŠå½“å‰æ•´ä¸ªç¨‹åºçš„çŠ¶æ€ä¿å­˜ä¸‹æ¥
        while True:
            yield checkpoint()
            while self.locked == 'ğŸ”’':
                yield checkpoint()
                pass
            yield checkpoint()
            self.locked = 'ğŸ”’'
            ...
# ç”¨ä¸€ä¸ªé¡ºåºçš„ç¨‹åºæ¨¡æ‹Ÿäº†ï¼ŒT1 æ‰§è¡Œä¸¤æ­¥ T2 æ‰§è¡Œä¸€éƒ¨         
def runner():
    obj = Mutex()
    T1 = obj.t1()
    T1 = obj.t1()
    T2 = obj.t1()
    ...
```

```python
thread_state = mutex_obj().T1()
thread_state.__next__() # å•æ­¥æ‰§è¡Œä¸€è¡Œ; see: execute()
```

ä»€ä¹ˆæ˜¯çŠ¶æ€ç©ºé—´ï¼Ÿ

- æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€æœºæ‰§è¡Œåºåˆ—
- BFS ç”Ÿæˆï¼Œåˆå¹¶é‡å¤çŠ¶æ€

```
[0]      T1
[1]      T2
[0,0]    T1 -> T1
[0,1]    T1 -> T2
[0,0,0]  T1 -> T1 -> T1
[0,0,1]  T1 -> T1 -> T2
[0,1,0]  T1 -> T2 -> T1
...      ...
```

## ä¸‰ã€Model Checking å’Œå·¥å…·çš„æ•…äº‹

### 1ã€Model Checker

> Model checking is a method for formally verifying finite-state systemsâ€”â€”åªè¦èƒ½ä¸ºç³»ç»Ÿå»ºç«‹æ¨¡å‹ï¼Œå°±èƒ½ç”¨ prove by brute-force è¯æ˜æ­£ç¡®/æ‰¾åˆ°é”™è¯¯ã€‚

Model checker çš„ä¸€åˆ‡å°±æ˜¯çŠ¶æ€æœºï¼

- Safety: æ²¡æœ‰çº¢è‰²èŠ‚ç‚¹ï¼Œçº¢è‰²çš„çŠ¶æ€ä¸å¯åˆ°è¾¾ï¼Œæ˜¯bug
    - G(V,E) ä¸Šçš„å¯è¾¾æ€§é—®é¢˜
- (Strong) Liveness: ä»ä»»æ„çŠ¶æ€å‡ºå‘ï¼Œéƒ½èƒ½åˆ°è¾¾ç»¿/è“è‰²çŠ¶æ€
    - G(V,E) ä¸Šçš„ä»€ä¹ˆé—®é¢˜ï¼Ÿä»é»‘è‰²èŠ‚ç‚¹å‡ºå‘ï¼Œé€šè¿‡ä¸€ä¸ªç¯ï¼Œè¿”å›è‡ªå·±ï¼ˆå¼ºè¿é€šåˆ†é‡è§£å†³ï¼‰
- å¦‚ä½•å±•ç¤ºè¿™ä¸ªçŠ¶æ€æœºï¼Ÿ
- å¦‚ä½•èƒ½é¿å…æ— æ•ˆçš„æ¢ç´¢ï¼Ÿ

### 2ã€æ›´å¤šçš„ Model Checker

çœŸå®ç¨‹åºçš„çŠ¶æ€ç©ºé—´å¤ªå¤§ï¼Ÿ

- [Model checking for programming languages using VeriSoft](https://dl.acm.org/doi/abs/10.1145/263699.263717)(POPL'97, ç¬¬ä¸€ä¸ª â€œsoftware model checkerâ€)
- [Finding and reproducing Heisenbugs in concurrent programs](https://dl.acm.org/doi/10.5555/1855741.1855760)(OSDI'08, Small Scope Hypothesis ğŸª³ğŸª³ğŸª³)
- [Using model checking to find serious file system errors](https://dl.acm.org/doi/10.1145/1189256.1189259) (OSDI'04, Best Paper ğŸ…ï¼Œå¯ä»¥ç”¨åœ¨ä¸å¹¶å‘çš„ç³»ç»Ÿä¸Š)

------

ä¸æ»¡è¶³äºç®€å•çš„å†…å­˜æ¨¡å‹ï¼Ÿ

- [VSync: Push-button verification and optimization for synchronization primitives on weak memory models](https://dl.acm.org/doi/abs/10.1145/3445814.3446748) (ASPLOS'21, Distinguished Paper ğŸ…)

### 3ã€å·¥å…·çš„æ•…äº‹

> æ²¡æœ‰äººèƒ½é˜»æ­¢ç¨‹åºå‘˜å†™ bugï¼Œä½†å·¥å…·å¯ä»¥ã€‚

è‡³ä»Šä¸ºæ­¢æˆ‘ä»¬ç”¨è¿‡çš„è‡ªåŠ¨åŒ–å·¥å…· (ä»–ä»¬æ‹¯æ•‘äº†ä½ æ— æ•°æ¬¡)

- Type safety check
- `-Wall -Werror`
- Differential testing
- Model checker
- â€¦â€¦

------

è¿™é—¨è¯¾çš„å¦ä¸€ä¸ª take-away

- æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªå·¨å¤§çš„å·¥ç¨‹
- æ²¡æœ‰å·¥å…· (ç¼–ç¨‹ã€æµ‹è¯•ã€è°ƒè¯•â€¦â€¦)ï¼Œä¸åšç³»ç»Ÿ

## æ€»ç»“

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: å¦‚ä½•ç†è§£å„ç§å¹¶å‘ç¨‹åºï¼Ÿ

------

Take-away message

- å¹¶å‘ç¨‹åº = çŠ¶æ€æœº
    - çº¿ç¨‹å…±äº«å†…å­˜
    - æ¯ä¸€æ­¥éç¡®å®šé€‰æ‹©çº¿ç¨‹æ‰§è¡Œ
- ç”»çŠ¶æ€æœºå°±å¯¹äº†
    - å½“ç„¶ï¼Œç”¨å·¥å…·å¸®ä½ ç”» (model checker)
