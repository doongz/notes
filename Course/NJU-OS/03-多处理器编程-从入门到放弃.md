# å¤šå¤„ç†å™¨ç¼–ç¨‹ï¼šä»å…¥é—¨åˆ°æ”¾å¼ƒ

ä¸€å®šè¦çœ‹è€å¸ˆè§†é¢‘è¯¾ https://www.bilibili.com/video/BV13u411X72Q 1:14:13 ä¹‹åçš„å†…å®¹ï¼Œå…¨æ˜¯é‡ç‚¹

## Overview

å¤ä¹ 

- ç¨‹åº (æºä»£ç Sã€äºŒè¿›åˆ¶ä»£ç C) = çŠ¶æ€æœº
  - ç¼–è¯‘å™¨ C=compile(S)
- åº”ç”¨è§†è§’çš„æ“ä½œç³»ç»Ÿ = syscall æŒ‡ä»¤

------

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: åœ¨å¤šå¤„ç†å™¨æ—¶ä»£ï¼Œä¸Šé¢çš„ç†è§£åº”è¯¥ä½œå‡ºæ€æ ·çš„å˜åŒ–ï¼Ÿ

------

æœ¬æ¬¡è¯¾ä¸»è¦å†…å®¹

- å¹¶å‘ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹
- çº¿ç¨‹åº“ `thread.h`
- å¤šçº¿ç¨‹å¸¦æ¥çš„éº»çƒ¦

## ä¸€ã€å…¥é—¨

### 1ã€Three Easy Pieces: å¹¶å‘

> Concurrent: existing, happening, or done *at the same time*.
>
> In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome. (Wikipedia)

ä¸ºä»€ä¹ˆåœ¨è¿™é—¨è¯¾ (å…ˆ) è®²å¹¶å‘ï¼Ÿ

- è®²å¹¶å‘
  - æ“ä½œç³»ç»Ÿæ˜¯æœ€æ—©çš„å¹¶å‘ç¨‹åºä¹‹ä¸€
  - ä»Šå¤©éåœ°éƒ½æ˜¯å¤šå¤„ç†å™¨ç³»ç»Ÿ (ä¸ºä»€ä¹ˆï¼Ÿ)
- å…ˆè®²å¹¶å‘
  - å®éªŒæ˜¯ bottom-up çš„ (L1: å¤šå¤„ç†å™¨ä¸Šçš„ `malloc`/`free`)

ç³»ç»Ÿè°ƒç”¨çš„ä»£ç æ˜¯ä¸–ç•Œä¸Šæœ€æ—©çš„å¹¶å‘ç¨‹åº

### 2ã€å¹¶å‘çš„åŸºæœ¬å•ä½ï¼šçº¿ç¨‹

å…±äº«å†…å­˜çš„å¤šä¸ªæ‰§è¡Œæµ

- æ‰§è¡Œæµæ‹¥æœ‰ç‹¬ç«‹çš„å †æ ˆ/å¯„å­˜å™¨
- å…±äº«å…¨éƒ¨çš„å†…å­˜ (æŒ‡é’ˆå¯ä»¥äº’ç›¸å¼•ç”¨)

------

ç”¨çŠ¶æ€æœºçš„è§†è§’å°±å¾ˆå®¹æ˜“ç†è§£äº†ï¼

![image-20220702225528562](./doc/image-20220702225528562.png)

### 3ã€å…¥é—¨ï¼š`thread.h` ç®€åŒ–çš„çº¿ç¨‹ API

æˆ‘ä»¬ä¸ºå¤§å®¶å°è£…äº†è¶…çº§å¥½ç”¨çš„çº¿ç¨‹ API ([`thread.h`](http://jyywiki.cn/pages/OS/2022/demos/thread.h))

- `create(fn)`
  - åˆ›å»ºä¸€ä¸ªå…¥å£å‡½æ•°æ˜¯ `fn`  çš„çº¿ç¨‹ï¼Œå¹¶ç«‹å³å¼€å§‹æ‰§è¡Œ
    - `void fn(int tid) { ... }`
    - å‚æ•° `tid` ä» 1 å¼€å§‹ç¼–å·
  - è¯­ä¹‰ï¼šåœ¨çŠ¶æ€ä¸­æ–°å¢ stack frame åˆ—è¡¨å¹¶åˆå§‹åŒ–ä¸º `fn(tid)`
- `join()`
  - ç­‰å¾…æ‰€æœ‰è¿è¡Œçº¿ç¨‹çš„ `fn` è¿”å›
  - åœ¨ `main` è¿”å›æ—¶ä¼šè‡ªåŠ¨ç­‰å¾…æ‰€æœ‰çº¿ç¨‹ç»“æŸ
  - è¯­ä¹‰ï¼šåœ¨æœ‰å…¶ä»–çº¿ç¨‹æœªæ‰§è¡Œå®Œæ—¶æ­»å¾ªç¯ï¼Œå¦åˆ™è¿”å›
- ç¼–è¯‘æ—¶éœ€è¦å¢åŠ  `-lpthread`

---

thread.h

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdatomic.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>

#define NTHREAD 64
enum { T_FREE = 0, T_LIVE, T_DEAD, };
struct thread {
  int id, status;
  pthread_t thread;
  void (*entry)(int);
};

struct thread tpool[NTHREAD], *tptr = tpool;

void *wrapper(void *arg) {
  struct thread *thread = (struct thread *)arg;
  thread->entry(thread->id);
  return NULL;
}

void create(void *fn) {
  assert(tptr - tpool < NTHREAD);
  *tptr = (struct thread) {
    .id = tptr - tpool + 1,
    .status = T_LIVE,
    .entry = fn,
  };
  pthread_create(&(tptr->thread), NULL, wrapper, tptr);
  ++tptr;
}

void join() {
  for (int i = 0; i < NTHREAD; i++) {
    struct thread *t = &tpool[i];
    if (t->status == T_LIVE) {
      pthread_join(t->thread, NULL);
      t->status = T_DEAD;
    }
  }
}

__attribute__((destructor)) void cleanup() {
  join();
}
```

Hello, Multi-threaded World!

a.c

```c
#include "thread.h"

void Ta() { while (1) { printf("a"); } }
void Tb() { while (1) { printf("b"); } }

int main() {
  create(Ta);
  create(Tb);
}
```

åˆ©ç”¨ `thread.h` å°±å¯ä»¥å†™å‡ºåˆ©ç”¨å¤šå¤„ç†å™¨çš„ç¨‹åºï¼

- æ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æŠŠçº¿ç¨‹æ”¾ç½®åœ¨ä¸åŒçš„å¤„ç†å™¨ä¸Š
- åœ¨åå°è¿è¡Œï¼Œå¯ä»¥çœ‹åˆ° CPU ä½¿ç”¨ç‡è¶…è¿‡äº† 100%

```bash
$ gcc a.c -lpthread && ./a.out
```

---

å¦‚ä½•è¯æ˜çº¿ç¨‹ç¡®å®å…±äº«å†…å­˜ï¼Ÿ

- [shm-test.c](http://jyywiki.cn/pages/OS/2022/demos/shm-test.c)

```c
#include "thread.h"

int x = 0;

void Thello(int id) {
  // int x = 0;
  usleep(id * 100000);
  printf("Hello from thread #%c\n", "123456789ABCDEF"[x++]);
}

int main() {
  for (int i = 0; i < 10; i++) {
    create(Thello);
  }
}
```

---

å¦‚ä½•è¯æ˜çº¿ç¨‹å…·æœ‰ç‹¬ç«‹å †æ ˆ (ä»¥åŠç¡®å®šå®ƒä»¬çš„èŒƒå›´)ï¼Ÿ

- [stack-probe.c](http://jyywiki.cn/pages/OS/2022/demos/stack-probe.c) (è¾“å‡ºæœ‰ç‚¹ä¹±ï¼Ÿæˆ‘ä»¬è¿˜æœ‰ `sort`!)

```c
#include "thread.h"

__thread char *base, *cur; // thread-local variables
__thread int id;

// objdump to see how thread-local variables are implemented
__attribute__((noinline)) void set_cur(void *ptr) { cur = ptr; }
__attribute__((noinline)) char *get_cur()         { return cur; }

void stackoverflow(int n) {
  set_cur(&n);
  if (n % 1024 == 0) {
    int sz = base - get_cur();
    printf("Stack size of T%d >= %d KB\n", id, sz / 1024);
  }
  stackoverflow(n + 1);
}

void Tprobe(int tid) {
  id = tid;
  base = (void *)&tid;
  stackoverflow(0);
}

int main() {
  setbuf(stdout, NULL);
  for (int i = 0; i < 4; i++) {
    create(Tprobe);
  }
}
```

```bash
$ gcc a.c -lpthread && ./a.out
# å‘½ä»¤è¡Œæ‰€æœ‰çš„è¾“å‡ºæ’åº
$ gcc a.c -lpthread && ./a.out | sort -nk 6

...
Stack size of T4 >= 8000 KB
Stack size of T2 >= 8064 KB
Stack size of T4 >= 8064 KB
Stack size of T2 >= 8128 KB
Stack size of T4 >= 8128 KB
```

å¯ä»¥è”æƒ³åˆ°ï¼Œæ¯ä¸ªæ ˆçš„å¤§å°æ˜¯ 8128 KB

```c
// a.c
#include "thread.h"

void Ta() { while (1) { ; } }

int main() {
  create(Ta);
}

$ gcc a.c -lpthread
```

å¦‚ä½•è§‚å¯Ÿæ˜¯å“ªä¸ªç³»ç»Ÿè°ƒç”¨åˆ›å»ºäº†çº¿ç¨‹ï¼Ÿ

```bash
$ strace ./a.out

execve("./a.out", ["./a.out"], 0x7fff877ef750 /* 28 vars */) = 0
brk(NULL)                               = 0x56179c316000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=87483, ...}) = 0
mmap(NULL, 87483, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe447e1c000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000b\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=144976, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe447e1a000
mmap(NULL, 2221184, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe4479ea000
mprotect(0x7fe447a04000, 2093056, PROT_NONE) = 0
mmap(0x7fe447c03000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19000) = 0x7fe447c03000
mmap(0x7fe447c05000, 13440, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe447c05000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20\35\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030928, ...}) = 0
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe4475f9000
mprotect(0x7fe4477e0000, 2097152, PROT_NONE) = 0
mmap(0x7fe4479e0000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fe4479e0000
mmap(0x7fe4479e6000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe4479e6000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe447e17000
arch_prctl(ARCH_SET_FS, 0x7fe447e17740) = 0
mprotect(0x7fe4479e0000, 16384, PROT_READ) = 0
mprotect(0x7fe447c03000, 4096, PROT_READ) = 0
mprotect(0x56179a63f000, 4096, PROT_READ) = 0
mprotect(0x7fe447e32000, 4096, PROT_READ) = 0
munmap(0x7fe447e1c000, 87483)           = 0
set_tid_address(0x7fe447e17a10)         = 29506
set_robust_list(0x7fe447e17a20, 24)     = 0
rt_sigaction(SIGRTMIN, {sa_handler=0x7fe4479efcb0, sa_mask=[], sa_flags=SA_RESTORER|SA_SIGINFO, sa_restorer=0x7fe4479fc980}, NULL, 8) = 0
rt_sigaction(SIGRT_1, {sa_handler=0x7fe4479efd50, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_SIGINFO, sa_restorer=0x7fe4479fc980}, NULL, 8) = 0
rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fe446df8000
mprotect(0x7fe446df9000, 8388608, PROT_READ|PROT_WRITE) = 0
brk(NULL)                               = 0x56179c316000
brk(0x56179c337000)                     = 0x56179c337000
clone(child_stack=0x7fe4475f7fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fe4475f89d0, tls=0x7fe4475f8700, child_tidptr=0x7fe4475f89d0) = 29507
futex(0x7fe4475f89d0, FUTEX_WAIT, 29507, NULL
```

å¯ä»¥çŒœåˆ°æ˜¯æœ€åçš„ `clone` ç³»ç»Ÿè°ƒç”¨ï¼Œåˆ›å»ºäº†çº¿ç¨‹

---

æ›´å¤šçš„ä¹ é¢˜

- åˆ›å»ºçº¿ç¨‹ä½¿ç”¨çš„æ˜¯å“ªä¸ªç³»ç»Ÿè°ƒç”¨ï¼Ÿ
- èƒ½ä¸èƒ½ç”¨ gdb è°ƒè¯•ï¼Ÿ
- åŸºæœ¬åŸåˆ™ï¼šæœ‰éœ€æ±‚ï¼Œå°±èƒ½åšåˆ° ([RTFM](https://sourceware.org/gdb/onlinedocs/gdb/Threads.html))

### 4ã€`thread.h` èƒŒåï¼šPOSIX Threads

æƒ³è¿›ä¸€æ­¥é…ç½®çº¿ç¨‹ï¼Ÿ

- è®¾ç½®æ›´å¤§çš„çº¿ç¨‹æ ˆ
- è®¾ç½® detach è¿è¡Œ (ä¸åœ¨è¿›ç¨‹ç»“æŸåè¢«æ€æ­»ï¼Œä¹Ÿä¸èƒ½ join)
- â€¦â€¦

------

POSIX ä¸ºæˆ‘ä»¬æä¾›äº†çº¿ç¨‹åº“ (pthreads)

- `man 7 pthreads`
- ç»ƒä¹ ï¼šæ”¹å†™ thread.hï¼Œä½¿å¾—çº¿ç¨‹æ‹¥æœ‰æ›´å¤§çš„æ ˆ
  - å¯ä»¥ç”¨ [stack-probe.c](http://jyywiki.cn/pages/OS/2022/demos/stack-probe.c) éªŒè¯

------

ç„¶è€Œï¼Œå¯æ€•çš„äº‹æƒ…æ­£åœ¨æ‚„æ‚„é€¼è¿‘â€¦â€¦

- å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­çº¿ç¨‹çš„ä»£ç å¯èƒ½åŒæ—¶æ‰§è¡Œ
  - ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œ `x++`ï¼Œç»“æœä¼šæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

## äºŒã€æ”¾å¼ƒ (1)ï¼šåŸå­æ€§

### 1ã€ä¾‹å­ï¼šå±±å¯¨å¤šçº¿ç¨‹æ”¯ä»˜å®

```c
unsigned int balance = 100;
int Alipay_withdraw(int amt) {
  if (balance >= amt) {
    balance -= amt;
    return SUCCESS;
  } else {
    return FAIL;
  }
}
```

ä¸¤ä¸ªçº¿ç¨‹å¹¶å‘æ”¯ä»˜ Â¥100 ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ[alipay.c](http://jyywiki.cn/pages/OS/2022/demos/alipay.c)

- è´¦æˆ·é‡Œä¼šå¤šå‡ºç”¨ä¸å®Œçš„é’±ï¼
- Bug/æ¼æ´ä¸è·Ÿä½ å¼€ç©ç¬‘ï¼šMt. Gox Hack æŸå¤± 650,000
  - ä»Šå¤©ä»·å€¼ $28,000,000,000

### 2ã€ä¾‹å­ï¼šæ±‚å’Œ

åˆ†ä¸¤ä¸ªçº¿ç¨‹ï¼Œè®¡ç®— 1+1+1+â€¦+1 (å…±è®¡ 2n ä¸ª 1)

```c
#define N 100000000
long sum = 0;

void Tsum() { for (int i = 0; i < N; i++) sum++; }

int main() {
  create(Tsum);
  create(Tsum); 
  join();
  printf("sum = %ld\n", sum);
}
```

[sum.c](http://jyywiki.cn/pages/OS/2022/demos/sum.c) è¿è¡Œç»“æœ

- 119790390, 99872322 (ç»“æœå¯ä»¥æ¯” `N` è¿˜è¦å°), ...
- Inline assembly ä¹Ÿä¸è¡Œ

---

åŠ ä¸Š `lock`ï¼Œä½†ç¨‹åºé€Ÿåº¦æ˜æ˜¾ä¸‹é™

```c
#define N 100000000
long sum = 0;

void Tsum() {
  for (int i = 0; i < n; i++) {
      asm volatile("lock add $1, %0": "+m"(sum));
  }
}

int main() {
  create(Tsum);
  create(Tsum); 
  join();
  printf("sum = %ld\n", sum);
}
```

### 3ã€åŸå­æ€§çš„ä¸§å¤±

> â€œç¨‹åº (ç”šè‡³æ˜¯ä¸€æ¡æŒ‡ä»¤) ç‹¬å å¤„ç†å™¨æ‰§è¡Œâ€ çš„åŸºæœ¬å‡è®¾åœ¨ç°ä»£å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šä¸å†æˆç«‹ã€‚

åŸå­æ€§ï¼šä¸€æ®µä»£ç æ‰§è¡Œ (ä¾‹å¦‚ `pay()`) ç‹¬å æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿ

- å•å¤„ç†å™¨å¤šçº¿ç¨‹
  - çº¿ç¨‹åœ¨è¿è¡Œæ—¶å¯èƒ½è¢«ä¸­æ–­ï¼Œåˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œ
- å¤šå¤„ç†å™¨å¤šçº¿ç¨‹
  - çº¿ç¨‹æ ¹æœ¬å°±æ˜¯å¹¶è¡Œæ‰§è¡Œçš„

------

(å†å²) 1960sï¼Œå¤§å®¶äº‰å…ˆåœ¨å…±äº«å†…å­˜ä¸Šå®ç°åŸå­æ€§ (äº’æ–¥)

- ä½†å‡ ä¹æ‰€æœ‰çš„å®ç°éƒ½æ˜¯é”™çš„ï¼Œç›´åˆ° [Dekker's Algorithm](https://en.wikipedia.org/wiki/Dekker's_algorithm)ï¼Œè¿˜åªèƒ½ä¿è¯ä¸¤ä¸ªçº¿ç¨‹çš„äº’æ–¥

### 4ã€åŸå­æ€§çš„ä¸§å¤±ï¼šæœ‰æ²¡æœ‰æ„Ÿåˆ°åæ€•ï¼Ÿ

`printf` è¿˜èƒ½åœ¨å¤šçº¿ç¨‹ç¨‹åºé‡Œè°ƒç”¨å—ï¼Ÿ

```
void thread1() { while (1) { printf("a"); } }
void thread2() { while (1) { printf("b"); } }
```

æˆ‘ä»¬éƒ½çŸ¥é“ printf æ˜¯æœ‰ç¼“å†²åŒºçš„ (ä¸ºä»€ä¹ˆï¼Ÿ)

- å¦‚æœæ‰§è¡Œ `buf[pos++] = ch` (`pos` å…±äº«) ä¸å°± ğŸ’¥ äº†å—ï¼Ÿ

------

RTFM!

### 5ã€å®ç°åŸå­æ€§

äº’æ–¥å’ŒåŸå­æ€§æ˜¯æœ¬å­¦æœŸçš„é‡è¦ä¸»é¢˜

- `lock(&lk)`
- `unlock(&lk)`
  - å®ç°ä¸´ç•ŒåŒº (critical section) ä¹‹é—´çš„ç»å¯¹ä¸²è¡ŒåŒ–
  - ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†ä¾ç„¶å¯ä»¥å¹¶è¡Œæ‰§è¡Œ

------

**99% çš„å¹¶å‘é—®é¢˜éƒ½å¯ä»¥ç”¨ä¸€ä¸ªé˜Ÿåˆ—è§£å†³**

- æŠŠå¤§ä»»åŠ¡åˆ‡åˆ†æˆå¯ä»¥å¹¶è¡Œçš„å°ä»»åŠ¡
- worker thread å»é”ä¿æŠ¤çš„é˜Ÿåˆ—é‡Œå–ä»»åŠ¡
- é™¤å»ä¸å¯å¹¶è¡Œçš„éƒ¨åˆ†ï¼Œå‰©ä¸‹çš„éƒ¨åˆ†å¯ä»¥è·å¾—çº¿æ€§çš„åŠ é€Ÿ
  - Thm. Tn<Tâˆ+T1/n ([PDC](https://web.mit.edu/dimitrib/www/pdc.html), Chap. 1)

## ä¸‰ã€æ”¾å¼ƒ (2)ï¼šé¡ºåº

### 1ã€ä¾‹å­ï¼šæ±‚å’Œ (å†æ¬¡å‡ºç°)

åˆ†ä¸¤ä¸ªçº¿ç¨‹ï¼Œè®¡ç®— 1+1+1+â€¦+1 (å…±è®¡ 2n ä¸ª 1)

```c
#define N 100000000
long sum = 0;

void Tsum() { for (int i = 0; i < N; i++) sum++; }

int main() {
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}
```

æˆ‘ä»¬å¥½åƒå¿˜è®°ç»™ [sum.c](http://jyywiki.cn/pages/OS/2022/demos/sum.c) æ·»åŠ ç¼–è¯‘ä¼˜åŒ–äº†ï¼Ÿ

- `-O1`: `gcc -O1 sum.c -lpthread && ./a.out`  100000000 ğŸ˜±ğŸ˜±
- `-O2`:  `gcc -O2 sum.c -lpthread && ./a.out` 200000000 ğŸ˜±ğŸ˜±ğŸ˜±
- å¾ªç¯çœ‹ä¸‹ç»“æœï¼š`while true; ./a.out; end`

### 2ã€é¡ºåºçš„ä¸§å¤±

> ç¼–è¯‘å™¨å¯¹å†…å­˜è®¿é—® â€œeventually consistentâ€ çš„å¤„ç†å¯¼è‡´å…±äº«å†…å­˜ä½œä¸ºçº¿ç¨‹åŒæ­¥å·¥å…·çš„å¤±æ•ˆã€‚

åˆšæ‰çš„ä¾‹å­

- `-O1`: `R[eax] = sum; R[eax] += N; sum = R[eax]`
- `-O2`: `sum += N;`
- (ä½ çš„ç¼–è¯‘å™¨ä¹Ÿè®¸æ˜¯ä¸åŒçš„ç»“æœ)

å¦ä¸€ä¸ªä¾‹å­

```c
while (!done);
// would be optimized to
if (!done) while (1);
```

### 3ã€å®ç°æºä»£ç çš„æŒ‰é¡ºåºç¿»è¯‘

åœ¨ while ä»£ç ä¸­æ’å…¥ â€œä¼˜åŒ–ä¸èƒ½ç©¿è¶Šâ€ çš„ barrier

- `asm volatile ("" ::: "memory");`
  - Barrier çš„å«ä¹‰æ˜¯ â€œå¯ä»¥è¯»å†™ä»»ä½•å†…å­˜â€
- ä½¿ç”¨ `volatile` å˜é‡
  - ä¿æŒ C è¯­ä¹‰å’Œæ±‡ç¼–è¯­ä¹‰ä¸€è‡´

```c
extern int volatile done;

while (!done) ;
```

## å››ã€æ”¾å¼ƒ (3)ï¼šå¯è§æ€§

### 1ã€ä¾‹å­

```c
int x = 0, y = 0;

void T1() {
  x = 1;
  asm volatile("" : : "memory"); // compiler barrier
  printf("y = %d\n", y);
}

void T2() {
  y = 1;
  asm volatile("" : : "memory"); // compiler barrier
  printf("x = %d\n",  x);
}
```

é—®é¢˜ï¼šæˆ‘ä»¬æœ€ç»ˆèƒ½çœ‹åˆ°å“ªäº›ç»“æœï¼Ÿ

**ä¸€å®šè¦ç”»å‡ºçŠ¶æ€æœºï¼Œæ‰èƒ½ç†è§£å¹¶å‘ç¨‹åºæ‰§è¡Œçš„è¡Œä¸º**

å¯ä»¥æ˜¯01ã€10ã€11ï¼Œæ— è®ºå¦‚ä½•ä¸å¯èƒ½æ˜¯ 00

![image-20220702230117046](./doc/image-20220702230117046.png)

---

- [mem-ordering.c](http://jyywiki.cn/pages/OS/2022/demos/mem-ordering.c)
  - è¾“å‡ºä¸å¥½è¯»ï¼Ÿpipe to `head -n 1000000 | sort | uniq -c`

```bash
$ ./a.out | head -n 1000000 | sort | uniq -c
```



```c
#include "thread.h"

int x = 0, y = 0;

atomic_int flag;
#define FLAG atomic_load(&flag)
#define FLAG_XOR(val) atomic_fetch_xor(&flag, val)
#define WAIT_FOR(cond) while (!(cond)) ;

 __attribute__((noinline))
void write_x_read_y() {
  int y_val;
  asm volatile(
    "movl $1, %0;" // x = 1
    "movl %2, %1;" // y_val = y
    : "=m"(x), "=r"(y_val) : "m"(y)
  );
  printf("%d ", y_val);
}

 __attribute__((noinline))
void write_y_read_x() {
  int x_val;
  asm volatile(
    "movl $1, %0;" // y = 1
    "movl %2, %1;" // x_val = x
    : "=m"(y), "=r"(x_val) : "m"(x)
  );
  printf("%d ", x_val);
}

void T1(int id) {
  while (1) {
    WAIT_FOR((FLAG & 1));
    write_x_read_y();
    FLAG_XOR(1);
  }
}

void T2() {
  while (1) {
    WAIT_FOR((FLAG & 2));
    write_y_read_x();
    FLAG_XOR(2);
  }
}

void Tsync() {
  while (1) {
    x = y = 0;
    __sync_synchronize(); // full barrier
    usleep(1);            // + delay
    assert(FLAG == 0);
    FLAG_XOR(3);
    // T1 and T2 clear 0/1-bit, respectively
    WAIT_FOR(FLAG == 0);
    printf("\n"); fflush(stdout);
  }
}

int main() {
  create(T1);
  create(T2);
  create(Tsync);
}
```

### 2ã€ç°ä»£å¤„ç†å™¨ï¼šå¤„ç†å™¨ä¹Ÿæ˜¯ (åŠ¨æ€) ç¼–è¯‘å™¨ï¼

å•ä¸ªå¤„ç†å™¨æŠŠæ±‡ç¼–ä»£ç  (ç”¨ç”µè·¯) â€œç¼–è¯‘â€ æˆæ›´å°çš„ Î¼ops

- RF[9] = load(RF[7] + 400)
- store(RF[12], RF[13])
- RF[3] = RF[4] + RF[5]
    - æ¯ä¸ª Î¼op éƒ½æœ‰ Fetch, Issue, Execute, Commit å››ä¸ªé˜¶æ®µ

---

åœ¨ä»»ä½•æ—¶åˆ»ï¼Œå¤„ç†å™¨éƒ½ç»´æŠ¤ä¸€ä¸ª Î¼op çš„ â€œæ± å­â€

- æ¯ä¸€å‘¨æœŸå‘æ± å­è¡¥å……å°½å¯èƒ½å¤šçš„ Î¼op
    - â€œå¤šå‘å°„â€
- æ¯ä¸€å‘¨æœŸ (åœ¨ä¸è¿åç¼–è¯‘æ­£ç¡®æ€§çš„å‰æä¸‹) æ‰§è¡Œå°½å¯èƒ½å¤šçš„Î¼op
    - â€œä¹±åºæ‰§è¡Œâ€ã€â€œæŒ‰åºæäº¤â€
- è¿™å°±æ˜¯ã€Šè®¡ç®—æœºä½“ç³»ç»“æ„ã€‹ (å‰©ä¸‹å°±æ˜¯æœ¨æ¡¶æ•ˆåº”ï¼Œå“ªé‡ŒçŸ­æ¿è¡¥å“ªé‡Œï¼‰

### 3ã€å¤šå¤„ç†å™¨é—´å³æ—¶å¯è§æ€§çš„ä¸§å¤±

> æ»¡è¶³å•å¤„ç†å™¨ eventual memory consistency çš„æ‰§è¡Œï¼Œåœ¨å¤šå¤„ç†å™¨ä¸Šå¯èƒ½æ— æ³•åºåˆ—åŒ–ï¼

å½“ xâ‰ y æ—¶ï¼Œå¯¹ x, y çš„å†…å­˜è¯»å†™å¯ä»¥äº¤æ¢é¡ºåº 

- å®ƒä»¬ç”šè‡³å¯ä»¥åœ¨åŒä¸€ä¸ªå‘¨æœŸé‡Œå®Œæˆ (åªè¦ load/store unit æ”¯æŒ)
- å¦‚æœå†™ x å‘ç”Ÿ cache missï¼Œå¯ä»¥è®©è¯» y å…ˆæ‰§è¡Œ
    - æ»¡è¶³ â€œå°½å¯èƒ½æ‰§è¡Œ Î¼opâ€ çš„åŸåˆ™ï¼Œæœ€å¤§åŒ–å¤„ç†å™¨æ€§èƒ½

```
     # <-----------+
movl $1, (x)   #   |
movl (y), %eax # --+
```

- åœ¨å¤šå¤„ç†å™¨ä¸Šçš„è¡¨ç°
    - ä¸¤ä¸ªå¤„ç†å™¨åˆ†åˆ«çœ‹åˆ° y=0 å’Œ x=0

### 4ã€å®½æ¾å†…å­˜æ¨¡å‹ (Relaxed/Weak Memory Model)

> å®½æ¾å†…å­˜æ¨¡å‹çš„ç›®çš„æ˜¯ä½¿å•å¤„ç†å™¨çš„æ‰§è¡Œæ›´é«˜æ•ˆã€‚

x86 å·²ç»æ˜¯å¸‚é¢ä¸Šèƒ½ä¹°åˆ°çš„ â€œæœ€å¼ºâ€ çš„å†…å­˜æ¨¡å‹äº† ğŸ˜‚

- è¿™ä¹Ÿæ˜¯ Intel è‡ªå·±ç»™è‡ªå·±åŠ çš„åŒ…è¢±
- çœ‹çœ‹ [ARM/RISC-V](https://research.swtch.com/mem-weak@2x.png) å§ï¼Œæ ¹æœ¬å°±æ˜¯ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿ

ARM/RISC-Vï¼š

![](./doc/mem-weak@2x.png)

(x86-TSO in [Hardware memory models](https://research.swtch.com/hwmm) by Russ Cox)

![img](./doc/x86-tso.png)

### 5ã€å®ç°é¡ºåºä¸€è‡´æ€§

![img](./doc/sc.png)

è½¯ä»¶åšä¸åˆ°ï¼Œç¡¬ä»¶æ¥å¸®å¿™

- Memory barrier:__sync_synchronize() RTFM:https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html
    - Compiler barrier + fence æŒ‡ä»¤
    - æ’å…¥ fence æŒ‡ä»¤åï¼Œå°†é˜»æ­¢ x=y=0
- åŸå­æŒ‡ä»¤ (lock prefix, lr/sc, ...)
    - `stdatomic.h`

## æ€»ç»“

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: å¦‚ä½•ç†è§£å¤šå¤„ç†å™¨ç³»ç»Ÿï¼Ÿ

------

Take-away message

- å¤šå¤„ç†å™¨ç¼–ç¨‹ï¼šå…¥é—¨
    - å¤šå¤„ç†å™¨ç¨‹åº = çŠ¶æ€æœº (å…±äº«å†…å­˜ï¼›éç¡®å®šé€‰æ‹©çº¿ç¨‹æ‰§è¡Œ)
    - thread.h = create + join
- å¤šå¤„ç†å™¨ç¼–ç¨‹ï¼šæ”¾å¼ƒä½ å¯¹ â€œç¨‹åºâ€ çš„æ—§ç†è§£
    - ä¸åŸå­ã€èƒ½ä¹±åºã€ä¸ç«‹å³å¯è§
        - æ¥è‡ªäºç¼–è¯‘ä¼˜åŒ– (å¤„ç†å™¨ä¹Ÿæ˜¯ç¼–è¯‘å™¨)
        - [Ad hoc synchronization considered harmful](https://www.usenix.org/events/osdi10/tech/full_papers/Xiong.pdf) (OSDI'10)