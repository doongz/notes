# å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥

## Overview

å¤ä¹ 

- çŠ¶æ€æœºã€çŠ¶æ€æœºã€çŠ¶æ€æœº

------

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: å¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°çº¿ç¨‹äº’æ–¥ï¼Ÿ

------

æœ¬æ¬¡è¯¾ä¸»è¦å†…å®¹

- è‡ªæ—‹é”çš„å®ç°
- äº’æ–¥é”çš„å®ç°

## æ”¶è·

### 1ã€å¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°çº¿ç¨‹äº’æ–¥ï¼Ÿ

äº’æ–¥ (mutual exclusion)ï¼Œâ€œäº’ç›¸æ’æ–¥â€

ä¸€æŠŠ â€œæ’ä»–æ€§â€ çš„é”â€”â€”å¯¹äºé”å¯¹è±¡ `lk`

- å¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„ `lock` ä¸èƒ½è¿”å›

å®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼š**ä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜**

- è½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘ (è‡ªæ—‹é”)
- ç”¨æˆ·ä¸å¤Ÿï¼Œå†…æ ¸æ¥å‡‘ (äº’æ–¥é”)
  - **æ‰¾åˆ°ä½ ä¾èµ–çš„å‡è®¾ï¼Œå¹¶å¤§èƒ†åœ°æ‰“ç ´å®ƒ**
- Fast/slow paths: æ€§èƒ½ä¼˜åŒ–çš„é‡è¦é€”å¾„

### 2ã€è‡ªæ—‹é”çš„å®ç°

ã€è¿™é‡Œçœ‹ 6.s081 çš„è¯¾æ›´å¥½ã€‘

è‡ªæ—‹é”çš„åè®®ï¼šæœ‰ä¸€æŠŠé’¥åŒ™ï¼Œæ”¾åœ¨æ¡Œå­ä¸Šï¼Œç”¨ä¸€ä¸ªä¸œè¥¿å’Œå®ƒäº¤æ¢ï¼Œåªæœ‰å¾—åˆ°é’¥åŒ™çš„äººæ‰å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº

å€ŸåŠ©ä¸€ä¸ªæŒ‡ä»¤ `lock xchg`ï¼ŒAtomic exchange (load + store) å®ç°äº’æ–¥

è¿™ä¸ªåŸå­æŒ‡ä»¤çš„æ¨¡å‹

- ä¿è¯ä¹‹å‰çš„ store éƒ½å†™å…¥å†…å­˜
- ä¿è¯ load/store ä¸ä¸åŸå­æŒ‡ä»¤ä¹±åº

Lock æŒ‡ä»¤çš„ç°ä»£å®ç°ï¼Œåœ¨ L1 cache å±‚ä¿æŒä¸€è‡´æ€§ (å› ä¸ºä¸åŒçš„æ ¸çš„L1 cache æ˜¯å…±äº«çš„)

- ç›¸å½“äºæ¯ä¸ª cache line æœ‰åˆ†åˆ«çš„é”
- store(x) è¿›å…¥ L1 ç¼“å­˜å³ä¿è¯å¯¹å…¶ä»–å¤„ç†å™¨å¯è§

**è‡ªæ—‹é”ç¼ºç‚¹ï¼šæ€§èƒ½é—®é¢˜**

- è‡ªæ—‹ (å…±äº«å˜é‡) ä¼šè§¦å‘å¤„ç†å™¨é—´çš„ç¼“å­˜åŒæ­¥ï¼Œå»¶è¿Ÿå¢åŠ 
- é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨**ç©ºè½¬**ï¼Œäº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½
- è·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹**å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»**ï¼Œæ“ä½œç³»ç»Ÿä¸ â€œæ„ŸçŸ¥â€ çº¿ç¨‹åœ¨åšä»€ä¹ˆï¼Œ100% çš„èµ„æºæµªè´¹

**è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯**

1. ä¸´ç•ŒåŒºå‡ ä¹ä¸ â€œæ‹¥å µâ€ï¼ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºï¼‰
2. æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

ä½†æ˜¯åº”ç”¨ç¨‹åºåšä¸åˆ°ï¼Œåªæœ‰æ“ä½œç³»ç»Ÿå¯ä»¥

ä½¿ç”¨åœºæ™¯ï¼š**æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ (çŸ­ä¸´ç•ŒåŒº)**ï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å ï¼Œä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”


### 3ã€äº’æ–¥é”çš„å®ç°

è‡ªæ—‹é” (çº¿ç¨‹ç›´æ¥å…±äº« locked)ï¼Œæ›´å¿«çš„ fast pathï¼Œxchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°

ç¡çœ é” (é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—® locked)ï¼Œæ›´å¿«çš„ slow pathï¼Œä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨ CPU

Futex ç®€æ˜“çš„å®ç°ï¼ˆè‡ªæ—‹é”å’Œç¡çœ é” ç»“åˆï¼‰ï¼Œå…ˆåœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹

- å¦‚æœè·å¾—é”ï¼Œç›´æ¥è¿›å…¥
- æœªèƒ½è·å¾—é”ï¼Œç³»ç»Ÿè°ƒç”¨
- è§£é”ä»¥åä¹Ÿéœ€è¦ç³»ç»Ÿè°ƒç”¨

Fast/slow paths: æ€§èƒ½ä¼˜åŒ–çš„é‡è¦é€”å¾„

## ä¸€ã€å…±äº«å†…å­˜ä¸Šçš„äº’æ–¥

### 1ã€å›é¡¾ï¼šå¹¶å‘ç¼–ç¨‹

ç†è§£å¹¶å‘çš„å·¥å…·

- çº¿ç¨‹ = äºº (å¤§è„‘èƒ½å®Œæˆå±€éƒ¨å­˜å‚¨å’Œè®¡ç®—)
- å…±äº«å†…å­˜ = ç‰©ç†ä¸–ç•Œ (ç‰©ç†ä¸–ç•Œå¤©ç”Ÿå¹¶è¡Œ)
- ä¸€åˆ‡éƒ½æ˜¯çŠ¶æ€æœº

### 2ã€å›é¡¾ï¼šäº’æ–¥ç®—æ³•

äº’æ–¥ (mutual exclusion)ï¼Œâ€œäº’ç›¸æ’æ–¥â€

- å®ç° `lock_t` æ•°æ®ç»“æ„å’Œ `lock/unlock` API:

```c
typedef struct {
  ...
} lock_t;
void lock(lock_t *lk);
void unlock(lock_t *lk);
```

------

ä¸€æŠŠ â€œæ’ä»–æ€§â€ çš„é”â€”â€”å¯¹äºé”å¯¹è±¡ `lk`

- å¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„ `lock` ä¸èƒ½è¿”å›

### 3ã€åœ¨å…±äº«å†…å­˜ä¸Šå®ç°äº’æ–¥

å¤±è´¥çš„å°è¯•

- [mutex-bad.py](http://jyywiki.cn/pages/OS/2022/demos/mutex-bad.py)

------

(éƒ¨åˆ†) æˆåŠŸçš„å°è¯•

- [peterson-barrier.c](http://jyywiki.cn/pages/OS/2022/demos/peterson-barrier.c)

------

å®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼š**ä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜**

- load (ç¯é¡¾å››å‘¨) çš„æ—¶å€™ä¸èƒ½å†™ï¼Œåªèƒ½ â€œçœ‹ä¸€çœ¼å°±æŠŠçœ¼ç›é—­ä¸Šâ€
    - çœ‹åˆ°çš„ä¸œè¥¿é©¬ä¸Šå°±è¿‡æ—¶äº†
- store (æ”¹å˜ç‰©ç†ä¸–ç•ŒçŠ¶æ€) çš„æ—¶å€™ä¸èƒ½è¯»ï¼Œåªèƒ½ â€œé—­ç€çœ¼ç›åŠ¨æ‰‹â€
    - ä¹Ÿä¸çŸ¥é“æŠŠä»€ä¹ˆæ”¹æˆäº†ä»€ä¹ˆ
- è¿™æ˜¯~~ç®€å•ã€ç²—æš´ (ç¨³å®š)ã€æœ‰æ•ˆ~~çš„ã€Šæ“ä½œç³»ç»Ÿã€‹è¯¾

## äºŒã€è‡ªæ—‹é” (Spin Lock)

è‡ªæ—‹é”ï¼šæœ‰ä¸€æŠŠé’¥åŒ™ï¼Œæ”¾åœ¨æ¡Œå­ä¸Šï¼Œç”¨ä¸€ä¸ªä¸œè¥¿å’Œå®ƒäº¤æ¢ï¼Œåªæœ‰å¾—åˆ°é’¥åŒ™çš„äººæ‰å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº

### 1ã€è§£å†³é—®é¢˜çš„ä¸¤ç§æ–¹æ³•

> æå‡ºç®—æ³•ã€è§£å†³é—®é¢˜ (Dekker/Peterson/...'s Protocols)

æˆ–è€…â€¦â€¦

> æ”¹å˜å‡è®¾ (è½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘)

------

**å‡è®¾ç¡¬ä»¶èƒ½ä¸ºæˆ‘ä»¬æä¾›ä¸€æ¡ â€œç¬é—´å®Œæˆâ€ çš„è¯» + å†™æŒ‡ä»¤**

- è¯·æ‰€æœ‰äººé—­ä¸Šçœ¼ç›ï¼Œçœ‹ä¸€çœ¼ (load)ï¼Œç„¶åè´´ä¸Šæ ‡ç­¾ (store)
    - å¦‚æœå¤šäººåŒæ—¶è¯·æ±‚ï¼Œç¡¬ä»¶é€‰å‡ºä¸€ä¸ª â€œèƒœè€…â€
    - â€œè´¥è€…â€ è¦ç­‰ â€œèƒœè€…â€ å®Œæˆåæ‰èƒ½ç»§ç»­æ‰§è¡Œ

### 2ã€x86 åŸå­æ“ä½œï¼š`LOCK` æŒ‡ä»¤å‰ç¼€

ä¾‹å­ï¼š[`sum-atomic.c`](http://jyywiki.cn/pages/OS/2022/demos/sum-atomic.c)

- `sum = 200000000`

```c
#include "thread.h"

#define N 100000000

long sum = 0;

void Tsum() {
  for (int i = 0; i < N; i++) {
    asm volatile("lock addq $1, %0": "+m"(sum));
  }
}

int main() {
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}
```



```bash
# æœ‰ lock å‰ç¼€
$ gcc sum-atomic.c -O2 -lpthread && ./a.out
sum = 200000000

# å»æ‰æ±‡ç¼–ä¸­çš„ lock å‰ç¼€
$ gcc sum-atomic.c -O2 -lpthread && ./a.out
sum = 100916012
```



------

Atomic exchange (load + store)

xchgï¼šä¸¤ä¸ªæ•°å€¼äº¤æ¢

```c
int xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}
```

æ›´å¤šçš„åŸå­æŒ‡ä»¤ï¼š[stdatomic.h](https://en.cppreference.com/w/cpp/header/stdatomic.h) (C11)

### 3ã€ç”¨ `xchg` å®ç°äº’æ–¥

å¦‚ä½•åè°ƒå®¿èˆè‹¥å¹²ä½åŒå­¦ä¸Šå•æ‰€é—®é¢˜ï¼Ÿ

- åœ¨å•æ‰€é—¨å£æ”¾ä¸€ä¸ªæ¡Œå­ (å…±äº«å˜é‡)
    - åˆå§‹æ—¶ï¼Œæ¡Œä¸Šæ˜¯ ğŸ”‘

------

å®ç°äº’æ–¥çš„åè®®

- æƒ³ä¸Šå•æ‰€çš„åŒå­¦ (ä¸€æ¡ xchg æŒ‡ä»¤)
    - å¤©é»‘è¯·é—­çœ¼
    - çœ‹ä¸€çœ¼æ¡Œå­ä¸Šæœ‰ä»€ä¹ˆ (ğŸ”‘ æˆ– ğŸ”)
    - æŠŠ ğŸ” æ”¾åˆ°æ¡Œä¸Š (è¦†ç›–ä¹‹å‰æœ‰çš„ä»»ä½•ä¸œè¥¿)
    - å¤©äº®è¯·ççœ¼ï¼›çœ‹åˆ° ğŸ”‘ æ‰å¯ä»¥è¿›å•æ‰€å“¦
- å‡ºå•æ‰€çš„åŒå­¦
    - æŠŠ ğŸ”‘ æ”¾åˆ°æ¡Œä¸Š

### 4ã€å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

```c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES)
}
```

```c
int locked = 0;
void lock() { while (xchg(&locked, 1)) ; }
void unlock() { xchg(&locked, 0); }
```

å¹¶å‘ç¼–ç¨‹ï¼šåƒä¸‡å°å¿ƒ

- åšè¯¦å°½çš„æµ‹è¯• (åœ¨æ­¤çœç•¥ï¼Œä½ ä»¬åš Labs å°±çŸ¥é“äº†)
- å°½å¯èƒ½åœ°è¯æ˜ ([model-checker.py](http://jyywiki.cn/pages/OS/2022/demos/model-checker.py) å’Œ [spinlock.py](http://jyywiki.cn/pages/OS/2022/demos/spinlock.py))

```python
class Spinlock:
    locked = ''

    @thread
    def t1(self):
        while True:
            while True:
                self.locked, seen = 'ğŸ”’', self.locked
                if seen != 'ğŸ”’': break
            cs = True
            del cs
            self.locked = ''

    @thread
    def t2(self):
        while True:
            while True:
                self.locked, seen = 'ğŸ”’', self.locked
                if seen != 'ğŸ”’': break
            cs = True
            del cs
            self.locked = ''

    @marker
    def mark_t1(self, state):
        if localvar(state, 't1', 'cs'): return 'blue'

    @marker
    def mark_t2(self, state):
        if localvar(state, 't2', 'cs'): return 'green'

    @marker
    def mark_both(self, state):
        if localvar(state, 't1', 'cs') and localvar(state, 't2', 'cs'):
            return 'red'

```

------

åŸå­æŒ‡ä»¤çš„æ¨¡å‹

- ä¿è¯ä¹‹å‰çš„ store éƒ½å†™å…¥å†…å­˜
- ä¿è¯ load/store ä¸ä¸åŸå­æŒ‡ä»¤ä¹±åº

### 5ã€åŸå­æŒ‡ä»¤çš„è¯ç”Ÿï¼šBus Lock (80486)

486 (20-50MHz) å°±æ”¯æŒ dual-socket äº†

![img](./doc/80486-arch.png)

ä¸€ä¸ªä¸»æ¿ä¸Šæœ‰ä¸¤ä¸ª CPUï¼Œéƒ½è¿ç€åŒä¸€ä¸ª memoryï¼Œæœ‰è®¿é—®å…±äº«å†…å­˜çš„åœºæ™¯

ç¡¬ä»¶ä¸Šå®ç°çš„é”

x86 ä½“ç³»ç»“æ„ä¸­ï¼Œç¼“å­˜çš„ä¸€è‡´æ€§æ˜¯ä¸ªå¾ˆå¤§çš„åŒ…è¢±

æ‰€æœ‰ CPU çš„ L1 cache éƒ½æ˜¯è¿èµ·æ¥çš„

ä¸€ä¸ª CPU æƒ³è¦æ‰§è¡Œ lockï¼Œæƒ³è¦è®¿é—® M çš„è¯ï¼Œè¦æŠŠå…¶ä»–æ‰€æœ‰ CPU çš„ M è¸¢å‡ºç¼“å­˜

![image-20220710150030702](./doc/image-20220710150030702.png)

### 6ã€Lock æŒ‡ä»¤çš„ç°ä»£å®ç°

åœ¨ L1 cache å±‚ä¿æŒä¸€è‡´æ€§ (ring/mesh bus)

- ç›¸å½“äºæ¯ä¸ª cache line æœ‰åˆ†åˆ«çš„é”
- store(x) è¿›å…¥ L1 ç¼“å­˜å³ä¿è¯å¯¹å…¶ä»–å¤„ç†å™¨å¯è§
    - ä½†è¦å°å¿ƒ store buffer å’Œä¹±åºæ‰§è¡Œ

------

L1 cache line æ ¹æ®çŠ¶æ€è¿›è¡Œåè°ƒ

- M (Modified), è„å€¼
- E (Exclusive), ç‹¬å è®¿é—®
- S (Shared), åªè¯»å…±äº«
- I (Invalid), ä¸æ‹¥æœ‰ cache line

### 7ã€RISC-V: å¦ä¸€ç§åŸå­æ“ä½œçš„è®¾è®¡

è€ƒè™‘å¸¸è§çš„åŸå­æ“ä½œï¼š

- atomic test-and-set
    - `reg = load(x); if (reg == XX) { store(x, YY); }`
- lock xchg
    - `reg = load(x); store(x, XX);`
- lock add
    - `t = load(x); t++; store(x, t);`

------

å®ƒä»¬çš„æœ¬è´¨éƒ½æ˜¯ï¼š

1. load
2. exec (å¤„ç†å™¨æœ¬åœ°å¯„å­˜å™¨çš„è¿ç®—)
3. store

### 8ã€Load-Reserved/Store-Conditional (LR/SC)

ã€0:50:38ã€‘å¼€å§‹è®²è§£ RISC-V çš„æŒ‡ä»¤

LR: åœ¨å†…å­˜ä¸Šæ ‡è®° reserved (ç›¯ä¸Šä½ äº†)ï¼Œä¸­æ–­ã€å…¶ä»–å¤„ç†å™¨å†™å…¥éƒ½ä¼šå¯¼è‡´æ ‡è®°æ¶ˆé™¤

```assembly
lr.w rd, (rs1)
  rd = M[rs1]
  reserve M[rs1]
```

------

SC: å¦‚æœ â€œç›¯ä¸Šâ€ æœªè¢«è§£é™¤ï¼Œåˆ™å†™å…¥

```assembly
sc.w rd, rs2, (rs1)
  if still reserved:
    M[rs1] = rs2
    rd = 0
  else:
    rd = nonzero
```

### 9ã€Compare-and-Swap çš„ LR/SC å®ç°

```c
int cas(int *addr, int cmp_val, int new_val) {
  int old_val = *addr;
  if (old_val == cmp_val) {
    *addr = new_val; return 0;
  } else { return 1; }
}
```

```assembly
cas:
  lr.w  t0, (a0)       # Load original value.
  bne   t0, a1, fail   # Doesnâ€™t match, so fail.
  sc.w  t0, a2, (a0)   # Try to update.
  bnez  t0, cas        # Retry if store-conditional failed.
  li a0, 0             # Set return to success.
  jr ra                # Return.
fail:
  li a0, 1             # Set return to failure.
  jr ra                # Return
```

lr å’Œ sc å¯ä»¥æ£€æŸ¥æœ‰æ²¡æœ‰äººå’Œæˆ‘å¹¶å‘çš„åœ¨åšè¿™ä»¶äº‹ï¼Œfail å¤±è´¥äº†ï¼Œè¡¨ç¤ºé”çš„æ‹¥å µ

### 10ã€LR/SC çš„ç¡¬ä»¶å®ç°

BOOM (Berkeley Out-of-Order Processor)

- [riscv-boom](https://github.com/riscv-boom/riscv-boom)
    - [`lsu/dcache.scala`](https://github.com/riscv-boom/riscv-boom/blob/master/src/main/scala/lsu/dcache.scala#L655)
    - ç•™æ„ `s2_sc_fail` çš„æ¡ä»¶
        - s2 æ˜¯æµæ°´çº¿ Stage 2
    - (yzh æ‰’å‡ºçš„ä»£ç )

![img](./doc/boom-pipeline-detailed.png)

## ä¸‰ã€äº’æ–¥é” (Mutex Lock)

### 1ã€è‡ªæ—‹é”çš„ç¼ºé™·

æ€§èƒ½é—®é¢˜ (0)

- è‡ªæ—‹ (å…±äº«å˜é‡) ä¼šè§¦å‘å¤„ç†å™¨é—´çš„ç¼“å­˜åŒæ­¥ï¼Œå»¶è¿Ÿå¢åŠ 

------

æ€§èƒ½é—®é¢˜ (1)

- é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨**ç©ºè½¬**
- äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½

------

æ€§èƒ½é—®é¢˜ (2)

- è·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹**å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»**
    - æ“ä½œç³»ç»Ÿä¸ â€œæ„ŸçŸ¥â€ çº¿ç¨‹åœ¨åšä»€ä¹ˆ
    - (ä½†ä¸ºä»€ä¹ˆä¸èƒ½å‘¢ï¼Ÿ)
- å®ç° 100% çš„èµ„æºæµªè´¹

### 2ã€Scalabilityï¼ˆä¼¸ç¼©æ€§ï¼‰: æ€§èƒ½çš„æ–°ç»´åº¦

> åŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ (CPU cycles) å’Œç©ºé—´ (mapped memory) ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚

- [sum-scalability.c](http://jyywiki.cn/pages/OS/2022/demos/sum-scalability.c)
- [thread-sync.h](http://jyywiki.cn/pages/OS/2022/demos/thread-sync.h)
    - ä¸¥è°¨çš„ç»Ÿè®¡å¾ˆéš¾
        - CPU åŠ¨æ€åŠŸè€—
        - ç³»ç»Ÿä¸­çš„å…¶ä»–è¿›ç¨‹
        - â€¦â€¦
- [Benchmarking crimes](https://www.cse.unsw.edu.au/~gernot/benchmarking-crimes.html)

---

sum-scalability.c

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
spinlock_t lock = SPIN_INIT();

long n, sum = 0;

void Tsum() {
  for (int i = 0; i < n; i++) {
    spin_lock(&lock);
    sum++;
    spin_unlock(&lock);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  int nthread = atoi(argv[1]);
  n = N / nthread;
  for (int i = 0; i < nthread; i++) {
    create(Tsum);
  }
  join();
  assert(sum == n * nthread);
}

```

thread-sync.h

```c
#include <semaphore.h>

// Spinlock
typedef int spinlock_t;
#define SPIN_INIT() 0

static inline int atomic_xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1":
    "+m"(*addr), "=a"(result) : "1"(newval) : "memory");
  return result;
}

void spin_lock(spinlock_t *lk) {
  while (1) {
    intptr_t value = atomic_xchg(lk, 1);
    if (value == 0) {
      break;
    }
  }
}
void spin_unlock(spinlock_t *lk) {
  atomic_xchg(lk, 0);
}

// Mutex
typedef pthread_mutex_t mutex_t;
#define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER
void mutex_lock(mutex_t *lk)   { pthread_mutex_lock(lk); }
void mutex_unlock(mutex_t *lk) { pthread_mutex_unlock(lk); }

// Conditional Variable
typedef pthread_cond_t cond_t;
#define COND_INIT() PTHREAD_COND_INITIALIZER
#define cond_wait pthread_cond_wait
#define cond_broadcast pthread_cond_broadcast
#define cond_signal pthread_cond_signal

// Semaphore
#define P sem_wait
#define V sem_post
#define SEM_INIT(sem, val) sem_init(sem, 0, val)

```

æµ‹è¯•ä¸€ä¸‹

```bash
$ gcc sum-scalability.c -O2 -lpthread

$ time ./a.out 1
real	0m0.130s
user	0m0.123s
sys	0m0.003s

$ time ./a.out 2
real	0m0.760s
user	0m1.497s
sys	0m0.007s

$ time ./a.out 3
real	0m1.169s
user	0m3.462s
sys	0m0.015s

$ time ./a.out 32
real	0m9.258s
user	1m7.500s
sys	0m0.242s
```

åŒæ ·çš„å·¥ä½œé‡ï¼Œçº¿ç¨‹è¶Šå¤šï¼Œæ•ˆç‡è¶Šæ…¢ï¼Œä¸ºä»€ä¹ˆï¼Ÿ

å› ä¸ºä¸Šé¢çš„ä¸‰ç§æ€§èƒ½é—®é¢˜

![img](./doc/spinlock-scalability.png)

### 3ã€è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯

1. ä¸´ç•ŒåŒºå‡ ä¹ä¸ â€œæ‹¥å µâ€ï¼ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºï¼‰
2. æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

ä½†æ˜¯åº”ç”¨ç¨‹åºåšä¸åˆ°

------

ä½¿ç”¨åœºæ™¯ï¼š**æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ (çŸ­ä¸´ç•ŒåŒº)**

- æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å 
    - ä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”
- (å¦‚æœæ˜¯è™šæ‹Ÿæœºå‘¢...ğŸ˜‚)
    - PAUSE æŒ‡ä»¤ä¼šè§¦å‘ VM Exit
- ä½†ä¾æ—§å¾ˆéš¾åšå¥½
    - [An analysis of Linux scalability to many cores](https://www.usenix.org/conference/osdi10/analysis-linux-scalability-many-cores) (OSDI'10)

### 4ã€å®ç°çº¿ç¨‹ + é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥

> ä½œä¸šé‚£ä¹ˆå¤šï¼Œä¸å…¶å¹²ç­‰ Online Judge å‘å¸ƒï¼Œä¸å¦‚æŠŠè‡ªå·± (CPU) è®©ç»™å…¶ä»–ä½œä¸š (çº¿ç¨‹) æ‰§è¡Œï¼Ÿ

â€œè®©â€ ä¸æ˜¯ C è¯­è¨€ä»£ç å¯ä»¥åšåˆ°çš„ (C ä»£ç åªèƒ½è®¡ç®—)

- æŠŠé”çš„å®ç°æ”¾åˆ°æ“ä½œç³»ç»Ÿé‡Œå°±å¥½å•¦ï¼

    - ```c
        syscall(SYSCALL_lock, &lk);
        ```

        - è¯•å›¾è·å¾— `lk`ï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹

    - ```c
        syscall(SYSCALL_unlock, &lk);
        ```

        - é‡Šæ”¾ `lk`ï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

---

æ“ä½œç³»ç»Ÿ = æ›´è¡£å®¤ç®¡ç†å‘˜

- å…ˆåˆ°çš„äºº (çº¿ç¨‹)
    - æˆåŠŸè·å¾—æ‰‹ç¯ï¼Œè¿›å…¥æ¸¸æ³³é¦† 
    - `*lk = ğŸ”’`ï¼Œç³»ç»Ÿè°ƒç”¨ç›´æ¥è¿”å›
- ååˆ°çš„äºº (çº¿ç¨‹)
    - ä¸èƒ½è¿›å…¥æ¸¸æ³³é¦†ï¼Œæ’é˜Ÿç­‰å¾…
    - çº¿ç¨‹æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ‰§è¡Œçº¿ç¨‹åˆ‡æ¢ (yield)
- æ´—å®Œæ¾¡å‡ºæ¥çš„äºº (çº¿ç¨‹)
    - äº¤è¿˜æ‰‹ç¯ç»™ç®¡ç†å‘˜ï¼›ç®¡ç†å‘˜æŠŠæ‰‹ç¯å†äº¤ç»™æ’é˜Ÿçš„äºº
    - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ç©ºï¼Œä»ç­‰å¾…é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªçº¿ç¨‹å…è®¸æ‰§è¡Œ
    - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œ`*lk = âœ…`
- **ç®¡ç†å‘˜ (OS) ä½¿ç”¨è‡ªæ—‹é”ç¡®ä¿è‡ªå·±å¤„ç†æ‰‹ç¯çš„è¿‡ç¨‹æ˜¯åŸå­çš„**

## å››ã€Futex = Spin + Mutex

### 1ã€å…³äºäº’æ–¥çš„ä¸€äº›åˆ†æ

è‡ªæ—‹é” (çº¿ç¨‹ç›´æ¥å…±äº« locked)

- æ›´å¿«çš„ fast path
    - xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
- æ›´æ…¢çš„ slow path
    - xchg å¤±è´¥ â†’ æµªè´¹ CPU è‡ªæ—‹ç­‰å¾…

------

ç¡çœ é” (é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—® locked)

- æ›´å¿«çš„ slow path
    - ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨ CPU
- æ›´æ…¢çš„ fast path
    - å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ (syscall)

### 2ã€Futex: Fast Userspace muTexes

> å°å­©å­æ‰åšé€‰æ‹©ã€‚æˆ‘å½“ç„¶æ˜¯å…¨éƒ½è¦å•¦ï¼

- Fast path: ä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›
- Slow path: ä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 
    - **æ€§èƒ½ä¼˜åŒ–çš„æœ€å¸¸è§æŠ€å·§**
        - çœ‹ average (frequent) case è€Œä¸æ˜¯ worst case

------

POSIX çº¿ç¨‹åº“ä¸­çš„äº’æ–¥é” (`pthread_mutex`)

- [sum-scalability.c](http://jyywiki.cn/pages/OS/2022/demos/sum-scalability.c)ï¼Œæ¢æˆ mutex
    - è§‚å¯Ÿç³»ç»Ÿè°ƒç”¨ (strace)
    - gdb è°ƒè¯•
        - set scheduler-locking on, info threads, thread X

çº¿ç¨‹åº“ä¸­çš„é”ï¼Œç»å¤§å¤šæ•°æƒ…å†µä¸‹ä¸ä¼šè§¦å‘ç³»ç»Ÿè°ƒç”¨ï¼ŒåŸå­æŒ‡ä»¤å°±è§£å†³äº†

åªæœ‰åœ¨æœ‰äº‰æŠ¢çš„æƒ…å†µä¸‹ï¼Œè§¦å‘ç³»ç»Ÿè°ƒç”¨

---

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
mutex_t lock = MUTEX_INIT();

long n, sum = 0;

void Tsum() {
  for (int i = 0; i < n; i++) {
    mutex_lock(&lock);
    sum++;
    mutex_unlock(&lock);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  int nthread = atoi(argv[1]);
  n = N / nthread;
  for (int i = 0; i < nthread; i++) {
    create(Tsum);
  }
  join();
  assert(sum == n * nthread);
}

```

æµ‹è¯•ä¸€ä¸‹

```bash
$ time ./a.out 1
real	0m0.203s
user	0m0.196s
sys	0m0.004s

$ time ./a.out 2
real	0m0.432s
user	0m0.331s
sys	0m0.374s

$ time ./a.out 3
real	0m0.552s
user	0m0.472s
sys	0m0.895s

$ time ./a.out 32
real	0m0.609s
user	0m0.706s
sys	0m3.881s

# -f çœ‹åˆ°å­è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨
$ strace -f ./a.out 32

```

### 3ã€Futex ç®€æ˜“çš„å®ç°

å…ˆåœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹

- å¦‚æœè·å¾—é”ï¼Œç›´æ¥è¿›å…¥
- æœªèƒ½è·å¾—é”ï¼Œç³»ç»Ÿè°ƒç”¨
- è§£é”ä»¥åä¹Ÿéœ€è¦ç³»ç»Ÿè°ƒç”¨
    - [futex.py](http://jyywiki.cn/pages/OS/2022/demos/futex.py)
    - æ›´å¥½çš„è®¾è®¡å¯ä»¥åœ¨ fast-path ä¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨

```python
class Futex:
    locked, waits = '', ''

    def tryacquire(self):
        if not self.locked:
            # Test-and-set (cmpxchg, x86)
            # Same effect, but more efficient than xchg
            self.locked = 'ğŸ”’'
            return ''
        else:
            return 'ğŸ”’'

    def release(self):
        if self.waits:
            self.waits = self.waits[1:]
        else:
            self.locked = ''

    @thread
    def t1(self):
        while True:
            if self.tryacquire() == 'ğŸ”’':     # User, ä¸èƒ½è·å¾—é”çš„è¯ï¼Œè¿›å†…æ ¸
                self.waits = self.waits + '1' # Kernel
                while '1' in self.waits:      # Kernel
                    pass
            cs = True                         # User
            del cs                            # User
            self.release()                    # Kernel

    @thread
    def t2(self):
        while True:
            if self.tryacquire() == 'ğŸ”’':
                self.waits = self.waits + '2'
                while '2' in self.waits:
                    pass
            cs = True
            del cs
            self.release()

    @thread
    def t3(self):
        while True:
            if self.tryacquire() == 'ğŸ”’':
                self.waits = self.waits + '3'
                while '3' in self.waits:
                    pass
            cs = True
            del cs
            self.release()

    @marker
    def mark_t1(self, state):
        if localvar(state, 't1', 'cs'): return 'blue'

    @marker
    def mark_t2(self, state):
        if localvar(state, 't2', 'cs'): return 'green'

    @marker
    def mark_t3(self, state):
        if localvar(state, 't3', 'cs'): return 'yellow'

    @marker
    def mark_both(self, state):
        count = 0
        for t in ['t1', 't2', 't3']:
            if localvar(state, t, 'cs'):
                count += 1
        if count > 1:
            return 'red'

```



------

RTFM (åŠé€€)

- futex (7), futex (2)
- [A futex overview and update](https://lwn.net/Articles/360699/) (LWN)
- [Futexes are tricky](http://jyywiki.cn/pages/OS/manuals/futexes-are-tricky.pdf) (è®º model checker çš„é‡è¦æ€§)
- (æˆ‘ä»¬ä¸è®²å¹¶å‘ç®—æ³•)

### 4ã€å¦‚ä½•è§£å†³çŠ¶æ€ç©ºé—´é‡Œçš„bug

å¦‚æœçŠ¶æ€ç©ºé—´é‡Œé¢æœ‰bugï¼ˆçº¢è‰²çš„èŠ‚ç‚¹ï¼‰,å¦‚ä½•è§£å†³ï¼Ÿ

æ‰¾ä¸€æ¡ä»æ ¹èŠ‚ç‚¹åˆ°åˆ°çº¢è‰²èŠ‚ç‚¹çš„è·¯å¾„ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢æœ€å°‘çš„è·¯å¾„ï¼ˆçº¢çº¢ç™½ç™½æœ€å°‘çš„è·¯å¾„ï¼‰ï¼Œè¿™å°±æ˜¯æœ€æ˜“ç†è§£çš„è·¯å¾„

è¿™ä¹Ÿæ‰¾åˆ°ä¸€ä¸ªæœ€æ˜“ç†è§£çš„åä¾‹

## æ€»ç»“

æœ¬æ¬¡è¯¾å›ç­”çš„é—®é¢˜

- **Q**: å¦‚ä½•åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šå®ç°äº’æ–¥ï¼Ÿ

------

Take-away message

- è½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘ (è‡ªæ—‹é”)
- ç”¨æˆ·ä¸å¤Ÿï¼Œå†…æ ¸æ¥å‡‘ (äº’æ–¥é”)
    - **æ‰¾åˆ°ä½ ä¾èµ–çš„å‡è®¾ï¼Œå¹¶å¤§èƒ†åœ°æ‰“ç ´å®ƒ**
- Fast/slow paths: æ€§èƒ½ä¼˜åŒ–çš„é‡è¦é€”å¾„